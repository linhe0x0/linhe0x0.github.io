{"version":3,"sources":["webpack:///path---articles-dont-fear-the-rebase-834852127d5d58e1e494.js","webpack:///./.cache/json/articles-dont-fear-the-rebase.json"],"names":["webpackJsonp","391","module","exports","data","markdownRemark","html","frontmatter","title","date","category","tags","cover","site","siteMetadata","url","thumbnail","defaultAuthor","donation","status","channel","alipay","wechat","share","pathContext","slug","excerpt","prev","next","fields"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,83LAAo8EC,aAAogHC,MAAA,cAAAC,KAAA,aAAAC,SAAA,KAAAC,MAAA,YAAAC,MAAA,OAA4FC,MAASC,cAAgBC,IAAA,6BAAAC,UAAA,GAAAC,cAAA,MAAAC,UAAoFC,QAAA,EAAAC,SAAyBC,OAAA,mDAAAC,OAAA,mEAAuIC,OAAA,KAAgBC,aAAgBC,KAAA,yBAAAjB,MAAA,cAAAkB,QAAA,qGAAAC,MAAA,EAAAC,MAA0LC,QAAUJ,KAAA,6BAAmClB,aAAgBC,MAAA,eAAAE,SAAA,KAAAC,MAAA,UAAAC,MAAA,KAAAH,KAAA,cAA0FiB,QAAA","file":"path---articles-dont-fear-the-rebase-834852127d5d58e1e494.js","sourcesContent":["webpackJsonp([266053112071045],{\n\n/***/ 391:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<ul>\\n<li>原文地址：<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">Don’t Fear The Rebase</a></li>\\n<li>原文作者：本文已获原作者 <a href=\\\"https://hackernoon.com/@jared.ready\\\">Jared Ready</a> 授权，转载请注明出处。</li>\\n<li>译者：<a href=\\\"https://github.com/sqrthree\\\">根号三</a></li>\\n</ul>\\n</blockquote>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpet99qa0jj31hc0icwg4.jpg\\\"></p>\\n<p>Git 的 <code>rebase</code> 命令是 Git 用户感到害怕和迷惑的一个常见原因，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase 是一个不可思议又充满魔力的怪兽，一上来不管三七二十一就改变历史。</p>\\n<p>Rebase 有点像指针。它是这样一个令人困惑的结构：每个人都在谈论它，但是你并不清楚为什么会有人使用它，然后突然一切都“啪嗒”一下，整个想法都变得显而易见和难以置信的简单。</p>\\n<p>在这篇文章中我会迫使你“啪嗒”一下，这样你就可以回到工作中并传播 <code>git rebase</code> 的神奇。</p>\\n<h3>究竟什么是 Rebase？</h3>\\n<blockquote>\\n<p>Git Rebase 是一个很简单的工具，用来取出一些在某个地方创建的提交，并假装它们一直是在另一个地方创建的。</p>\\n</blockquote>\\n<p><strong>好的，我知道了。可是这意味着什么呢？</strong></p>\\n<p>让我们来看一个例子。我们在这个仓库中有两个分支：<code>master</code> 和 <code>feature/foo</code>。<code>feature/foo</code> 是基于 <code>master</code> 分离出去的分支，并且在 <code>feature/foo</code> 分支上产生了一些提交。<code>master</code> 也发生了移动，就像世界不会因为少了你的关注而停滞不前。</p>\\n<p><img src=\\\"https://ws1.sinaimg.cn/large/006tKfTcly1fpeujk93g1j318g0rg41j.jpg\\\"></p>\\n<p>这是目前的状态</p>\\n<p>我们想将一些更改从 <code>master</code> 整合进 <code>feature/foo</code> 中，但是我们不想每次执行这个整合时都处理一次令人讨厌的合并提交。</p>\\n<p><strong>Rebase 就是一个让你有能力整合发生在源分支上的更改而不需要执行合并（merge）从而不会产生合并提交的工具。</strong></p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpeups3ff0j31jk0g9acl.jpg\\\"></p>\\n<p>这是 rebase 之后的情况。（fast-forward 版本）</p>\\n<p><em>D</em> 和 <em>F</em> 两个提交已经被<strong>重新放在</strong>了 <code>master</code> 的顶部，即当前指向的 <em>G</em> 提交。你可能会注意到这两个提交实际上已经被重命名为了 <em>D`</em> 和 <em>F`</em>，并且提交的 SHA-1 值也不一样。这是为什么呢？</p>\\n<h4>Git 中的提交不可变更</h4>\\n<p>一个提交具有一些与之相关的属性：一个父提交、一个时间戳、提交时仓库的快照（提交不仅仅是变更集）。这些值是 Git 在计算标识一个提交的 SHA-1 时所用到的。</p>\\n<p>由于提交是不可变的，并且一个 SHA-1 应该唯一标识一个提交，因此 Git 需要创建一个新的提交来包含原始提交中相同的仓库快照，但是每个提交都有一个<strong>不同的父提交和时间戳</strong>。</p>\\n<p>这导致新的提交看起来与原始提交相同，但是具有不同的 SHA-1。</p>\\n<hr>\\n<h3>找出提交</h3>\\n<p>当我们从 <code>feature/foo</code> 分支上运行 <code>git rebase master</code> 时，Git 怎么知道哪些提交需要移动呢？</p>\\n<p>让我们先看看每个分支上的提交的文氏图（Venn diagram）。</p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpevtxsiwvj318g0ufads.jpg\\\"></p>\\n<p>从上图中我们可以看到每一个分支都有 <em>A</em>、<em>B</em> 和 <em>C</em> 这几个提交。<code>master</code> 分支还拥有 <em>E</em> 和 <em>G</em> 提交但是 <code>feature/foo</code> 分支没有。<code>feature/foo</code> 拥有 <em>F</em> 和 <em>D</em> 提交但是 <code>master</code> 分支没有。</p>\\n<p>Git 会做一个减法：<code>{commits on feature/foo} — {commits on master}</code>，来找出正确的提交。这个结果就是 <em>D</em> 和 <em>F</em>。</p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpevx9tq3rj318g0v577x.jpg\\\"></p>\\n<h4>我们能证明这一点吗？</h4>\\n<p>当然，一个简单方式是使用 <code>git log</code> 来看我们从这组减法中得到的确切提交。</p>\\n<p><code>git log master..feature/foo</code> <strong>会</strong> 向我们展示 <code>bc1f36b</code> 和 <code>640e713</code> 提交。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpew0jd7j1j318g045wfn.jpg\\\"></p>\\n<p>如果你在 .. 后省略了一个分支，那么会默认为是当前分支。</p>\\n<p>看起来不错。让我们来看看更广泛的视角以确保我不是在糊弄。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpew54td7vj318g07ajty.jpg\\\"></p>\\n<p>这些 SHA-1 看起来很熟悉。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpew5prdn4j318g0790v3.jpg\\\"></p>\\n<p>这里并没有 76f5fd1 和 22033eb，因为我们是从 master 分支的 7559a0b 提交开始分离的。</p>\\n<hr>\\n<p>如果我们现在执行一个 <code>rebase</code> 到 <code>master</code>，我们会立即看到 <code>76f5fd1</code> 和 <code>22033eb</code> 出现在我们在 <code>feature/foo</code> 分支上创建出的提交的前面。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpewljxlmej318g05y0u9.jpg\\\"></p>\\n<p>Git 正在像我们期望中的那样重新应用提交。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpewouxdggj318g0a0dj0.jpg\\\"></p>\\n<p>看起来熟悉吗？</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpewpe9c16j318g0d0jt3.jpg\\\"></p>\\n<p>我们之前见过这个了。</p>\\n<p>我们现在有一个很好的线性历史。你应该能够想到在此刻 fast-forward 的合并会如何发生。</p>\\n<blockquote>\\n<p>rebase 策略还有一个已知的额外好处，就是如果你的 CI 管道（CI pipeline）在功能分支上通过了，那么在合并后的主分支上它也会通过。如果是一个非线性的合并策略，你就不能保证这一点。</p>\\n</blockquote>\\n<hr>\\n<h3>使用强制手段</h3>\\n<p>如果 <code>feature/foo</code> 分支已经被推送过（push），并且在 rebase 之后尝试进行另一个推送，Git 会很委婉地拒绝推送。这是为什么呢？</p>\\n<p><strong>Git 会尽其所能来防止意外覆盖历史，这是一件好事。</strong></p>\\n<p>我们来看一下 Git 所认为的 <code>feature/foo</code> 分支在远程仓库中是什么样的？</p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpexhw94i1j31080oi76p.jpg\\\"></p>\\n<p>现在我们来看一下我们告诉 Git 要做的事情。</p>\\n<p><img src=\\\"https://ws4.sinaimg.cn/large/006tKfTcly1fpexk964q3j318g0fl40s.jpg\\\"></p>\\n<p>从 Git 的角度来看，提交 <em>D</em> 和 <em>F</em> 即将丢弃。Git 会给你这样一行友好的信息：<code>Updates were rejected because the tip of your current branch is behind</code>。</p>\\n<p>你或许会说，“但是我可以在你这个很棒的图片中清晰地看到，<code>feature/foo</code> 分支比之前更进一步了啊。” 这是一个很好的观察结果，但是 Git 只会看到远程仓库中的 <code>feature/foo</code> 包含 <code>bc1f36b</code> 和 <code>640e713</code>，但是你本地的 <code>feature/foo</code> 不包含这些提交。因此为了不丢失这些提交，Git 会委婉地拒绝一个正常的 <code>git push</code>，并要求你执行 <code>git push --force</code>。</p>\\n<hr>\\n<p>如果你从这篇文章中带走一件东西，那么请记住，rebase 只是简单的查找出在某个分支上创建的提交，然后使用相同的内容但是新的父提交或基础提交（<em>base</em> commit）来创建新的提交。</p>\\n<hr>\\n<p>如果你喜欢我的文章，请为我点赞。</p>\\n<p>关注 <a href=\\\"https://medium.com/@hackernoon\\\">Hackernoon</a> 和 <a href=\\\"https://medium.com/@jared.ready\\\">Jared Ready</a> 来获取更多高质量的软件工程相关的内容吧。</p>\\n<p><a href=\\\"https://goo.gl/w4Pbea\\\"><img src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\\\"></a></p>\\n<blockquote>\\n<p>本文根据 <a href=\\\"https://hackernoon.com/@jared.ready\\\">Jared Ready</a> 的《<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">Don’t Fear The Rebase</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">https://hackernoon.com/dont-fear-the-rebase-bca683888dae</a></p>\\n</blockquote>\\n<blockquote>\\n<p>本文根据 <a href=\\\"https://hackernoon.com/@jared.ready\\\">Jared Ready</a> 的《<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">Don’t Fear The Rebase</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">https://hackernoon.com/dont-fear-the-rebase-bca683888dae</a></p>\\n</blockquote>\",\"frontmatter\":{\"title\":\"不要害怕 Rebase\",\"date\":\"2018-03-20\",\"category\":\"技术\",\"tags\":[\"译文\",\"Git\"],\"cover\":null}},\"site\":{\"siteMetadata\":{\"url\":\"http://blog.sqrtthree.com/\",\"thumbnail\":\"\",\"defaultAuthor\":\"根号三\",\"donation\":{\"status\":true,\"channel\":{\"alipay\":\"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG\",\"wechat\":\"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG\"}},\"share\":true}}},\"pathContext\":{\"slug\":\"/dont-fear-the-rebase/\",\"title\":\"不要害怕 Rebase\",\"excerpt\":\"原文地址： Don’t Fear The Rebase 原文作者：本文已获原作者  Jared Ready  授权，转载请注明出处。 译者： 根号三 Git 的  rebase  命令是 Git…\",\"prev\":false,\"next\":{\"fields\":{\"slug\":\"/random-number-in-golang/\"},\"frontmatter\":{\"title\":\"GoLang 中的随机数\",\"category\":\"技术\",\"tags\":[\"GoLang\"],\"cover\":null,\"date\":\"2018-03-16\"},\"excerpt\":\"随机数我们都知道，就是计算机通过某种算法，“随机”的生成一个数字。很多编程语言都有内置的方法来生成随机数，那么 GoLang…\"}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-dont-fear-the-rebase-834852127d5d58e1e494.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<ul>\\n<li>原文地址：<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">Don’t Fear The Rebase</a></li>\\n<li>原文作者：本文已获原作者 <a href=\\\"https://hackernoon.com/@jared.ready\\\">Jared Ready</a> 授权，转载请注明出处。</li>\\n<li>译者：<a href=\\\"https://github.com/sqrthree\\\">根号三</a></li>\\n</ul>\\n</blockquote>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpet99qa0jj31hc0icwg4.jpg\\\"></p>\\n<p>Git 的 <code>rebase</code> 命令是 Git 用户感到害怕和迷惑的一个常见原因，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase 是一个不可思议又充满魔力的怪兽，一上来不管三七二十一就改变历史。</p>\\n<p>Rebase 有点像指针。它是这样一个令人困惑的结构：每个人都在谈论它，但是你并不清楚为什么会有人使用它，然后突然一切都“啪嗒”一下，整个想法都变得显而易见和难以置信的简单。</p>\\n<p>在这篇文章中我会迫使你“啪嗒”一下，这样你就可以回到工作中并传播 <code>git rebase</code> 的神奇。</p>\\n<h3>究竟什么是 Rebase？</h3>\\n<blockquote>\\n<p>Git Rebase 是一个很简单的工具，用来取出一些在某个地方创建的提交，并假装它们一直是在另一个地方创建的。</p>\\n</blockquote>\\n<p><strong>好的，我知道了。可是这意味着什么呢？</strong></p>\\n<p>让我们来看一个例子。我们在这个仓库中有两个分支：<code>master</code> 和 <code>feature/foo</code>。<code>feature/foo</code> 是基于 <code>master</code> 分离出去的分支，并且在 <code>feature/foo</code> 分支上产生了一些提交。<code>master</code> 也发生了移动，就像世界不会因为少了你的关注而停滞不前。</p>\\n<p><img src=\\\"https://ws1.sinaimg.cn/large/006tKfTcly1fpeujk93g1j318g0rg41j.jpg\\\"></p>\\n<p>这是目前的状态</p>\\n<p>我们想将一些更改从 <code>master</code> 整合进 <code>feature/foo</code> 中，但是我们不想每次执行这个整合时都处理一次令人讨厌的合并提交。</p>\\n<p><strong>Rebase 就是一个让你有能力整合发生在源分支上的更改而不需要执行合并（merge）从而不会产生合并提交的工具。</strong></p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpeups3ff0j31jk0g9acl.jpg\\\"></p>\\n<p>这是 rebase 之后的情况。（fast-forward 版本）</p>\\n<p><em>D</em> 和 <em>F</em> 两个提交已经被<strong>重新放在</strong>了 <code>master</code> 的顶部，即当前指向的 <em>G</em> 提交。你可能会注意到这两个提交实际上已经被重命名为了 <em>D`</em> 和 <em>F`</em>，并且提交的 SHA-1 值也不一样。这是为什么呢？</p>\\n<h4>Git 中的提交不可变更</h4>\\n<p>一个提交具有一些与之相关的属性：一个父提交、一个时间戳、提交时仓库的快照（提交不仅仅是变更集）。这些值是 Git 在计算标识一个提交的 SHA-1 时所用到的。</p>\\n<p>由于提交是不可变的，并且一个 SHA-1 应该唯一标识一个提交，因此 Git 需要创建一个新的提交来包含原始提交中相同的仓库快照，但是每个提交都有一个<strong>不同的父提交和时间戳</strong>。</p>\\n<p>这导致新的提交看起来与原始提交相同，但是具有不同的 SHA-1。</p>\\n<hr>\\n<h3>找出提交</h3>\\n<p>当我们从 <code>feature/foo</code> 分支上运行 <code>git rebase master</code> 时，Git 怎么知道哪些提交需要移动呢？</p>\\n<p>让我们先看看每个分支上的提交的文氏图（Venn diagram）。</p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpevtxsiwvj318g0ufads.jpg\\\"></p>\\n<p>从上图中我们可以看到每一个分支都有 <em>A</em>、<em>B</em> 和 <em>C</em> 这几个提交。<code>master</code> 分支还拥有 <em>E</em> 和 <em>G</em> 提交但是 <code>feature/foo</code> 分支没有。<code>feature/foo</code> 拥有 <em>F</em> 和 <em>D</em> 提交但是 <code>master</code> 分支没有。</p>\\n<p>Git 会做一个减法：<code>{commits on feature/foo} — {commits on master}</code>，来找出正确的提交。这个结果就是 <em>D</em> 和 <em>F</em>。</p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpevx9tq3rj318g0v577x.jpg\\\"></p>\\n<h4>我们能证明这一点吗？</h4>\\n<p>当然，一个简单方式是使用 <code>git log</code> 来看我们从这组减法中得到的确切提交。</p>\\n<p><code>git log master..feature/foo</code> <strong>会</strong> 向我们展示 <code>bc1f36b</code> 和 <code>640e713</code> 提交。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpew0jd7j1j318g045wfn.jpg\\\"></p>\\n<p>如果你在 .. 后省略了一个分支，那么会默认为是当前分支。</p>\\n<p>看起来不错。让我们来看看更广泛的视角以确保我不是在糊弄。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpew54td7vj318g07ajty.jpg\\\"></p>\\n<p>这些 SHA-1 看起来很熟悉。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpew5prdn4j318g0790v3.jpg\\\"></p>\\n<p>这里并没有 76f5fd1 和 22033eb，因为我们是从 master 分支的 7559a0b 提交开始分离的。</p>\\n<hr>\\n<p>如果我们现在执行一个 <code>rebase</code> 到 <code>master</code>，我们会立即看到 <code>76f5fd1</code> 和 <code>22033eb</code> 出现在我们在 <code>feature/foo</code> 分支上创建出的提交的前面。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpewljxlmej318g05y0u9.jpg\\\"></p>\\n<p>Git 正在像我们期望中的那样重新应用提交。</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpewouxdggj318g0a0dj0.jpg\\\"></p>\\n<p>看起来熟悉吗？</p>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpewpe9c16j318g0d0jt3.jpg\\\"></p>\\n<p>我们之前见过这个了。</p>\\n<p>我们现在有一个很好的线性历史。你应该能够想到在此刻 fast-forward 的合并会如何发生。</p>\\n<blockquote>\\n<p>rebase 策略还有一个已知的额外好处，就是如果你的 CI 管道（CI pipeline）在功能分支上通过了，那么在合并后的主分支上它也会通过。如果是一个非线性的合并策略，你就不能保证这一点。</p>\\n</blockquote>\\n<hr>\\n<h3>使用强制手段</h3>\\n<p>如果 <code>feature/foo</code> 分支已经被推送过（push），并且在 rebase 之后尝试进行另一个推送，Git 会很委婉地拒绝推送。这是为什么呢？</p>\\n<p><strong>Git 会尽其所能来防止意外覆盖历史，这是一件好事。</strong></p>\\n<p>我们来看一下 Git 所认为的 <code>feature/foo</code> 分支在远程仓库中是什么样的？</p>\\n<p><img src=\\\"https://ws2.sinaimg.cn/large/006tKfTcly1fpexhw94i1j31080oi76p.jpg\\\"></p>\\n<p>现在我们来看一下我们告诉 Git 要做的事情。</p>\\n<p><img src=\\\"https://ws4.sinaimg.cn/large/006tKfTcly1fpexk964q3j318g0fl40s.jpg\\\"></p>\\n<p>从 Git 的角度来看，提交 <em>D</em> 和 <em>F</em> 即将丢弃。Git 会给你这样一行友好的信息：<code>Updates were rejected because the tip of your current branch is behind</code>。</p>\\n<p>你或许会说，“但是我可以在你这个很棒的图片中清晰地看到，<code>feature/foo</code> 分支比之前更进一步了啊。” 这是一个很好的观察结果，但是 Git 只会看到远程仓库中的 <code>feature/foo</code> 包含 <code>bc1f36b</code> 和 <code>640e713</code>，但是你本地的 <code>feature/foo</code> 不包含这些提交。因此为了不丢失这些提交，Git 会委婉地拒绝一个正常的 <code>git push</code>，并要求你执行 <code>git push --force</code>。</p>\\n<hr>\\n<p>如果你从这篇文章中带走一件东西，那么请记住，rebase 只是简单的查找出在某个分支上创建的提交，然后使用相同的内容但是新的父提交或基础提交（<em>base</em> commit）来创建新的提交。</p>\\n<hr>\\n<p>如果你喜欢我的文章，请为我点赞。</p>\\n<p>关注 <a href=\\\"https://medium.com/@hackernoon\\\">Hackernoon</a> 和 <a href=\\\"https://medium.com/@jared.ready\\\">Jared Ready</a> 来获取更多高质量的软件工程相关的内容吧。</p>\\n<p><a href=\\\"https://goo.gl/w4Pbea\\\"><img src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\\\"></a></p>\\n<blockquote>\\n<p>本文根据 <a href=\\\"https://hackernoon.com/@jared.ready\\\">Jared Ready</a> 的《<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">Don’t Fear The Rebase</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">https://hackernoon.com/dont-fear-the-rebase-bca683888dae</a></p>\\n</blockquote>\\n<blockquote>\\n<p>本文根据 <a href=\\\"https://hackernoon.com/@jared.ready\\\">Jared Ready</a> 的《<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">Don’t Fear The Rebase</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href=\\\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\\\">https://hackernoon.com/dont-fear-the-rebase-bca683888dae</a></p>\\n</blockquote>\",\"frontmatter\":{\"title\":\"不要害怕 Rebase\",\"date\":\"2018-03-20\",\"category\":\"技术\",\"tags\":[\"译文\",\"Git\"],\"cover\":null}},\"site\":{\"siteMetadata\":{\"url\":\"http://blog.sqrtthree.com/\",\"thumbnail\":\"\",\"defaultAuthor\":\"根号三\",\"donation\":{\"status\":true,\"channel\":{\"alipay\":\"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG\",\"wechat\":\"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG\"}},\"share\":true}}},\"pathContext\":{\"slug\":\"/dont-fear-the-rebase/\",\"title\":\"不要害怕 Rebase\",\"excerpt\":\"原文地址： Don’t Fear The Rebase 原文作者：本文已获原作者  Jared Ready  授权，转载请注明出处。 译者： 根号三 Git 的  rebase  命令是 Git…\",\"prev\":false,\"next\":{\"fields\":{\"slug\":\"/random-number-in-golang/\"},\"frontmatter\":{\"title\":\"GoLang 中的随机数\",\"category\":\"技术\",\"tags\":[\"GoLang\"],\"cover\":null,\"date\":\"2018-03-16\"},\"excerpt\":\"随机数我们都知道，就是计算机通过某种算法，“随机”的生成一个数字。很多编程语言都有内置的方法来生成随机数，那么 GoLang…\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-dont-fear-the-rebase.json\n// module id = 391\n// module chunks = 266053112071045"],"sourceRoot":""}