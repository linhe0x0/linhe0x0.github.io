{"version":3,"sources":["webpack:///path---utf-8-to-b-64-1b4b9c84d2d0995e0e1e.js","webpack:///./.cache/json/utf-8-to-b-64.json"],"names":["webpackJsonp","338","module","exports","data","markdownRemark","html","frontmatter","title","date","category","tags","pathContext","slug","prev","fields","cover","excerpt","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,8+FAA4hFC,aAAweC,MAAA,oCAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,QAA8FC,aAAgBC,KAAA,gBAAAL,MAAA,oCAAAM,MAA2EC,QAAUF,KAAA,uCAA6CN,aAAgBC,MAAA,+BAAAE,SAAA,KAAAC,MAAA,kBAAAK,MAAA,KAAAP,KAAA,cAAkHQ,QAAA,qGAA+GC,MAAA","file":"path---utf-8-to-b-64-1b4b9c84d2d0995e0e1e.js","sourcesContent":["webpackJsonp([195586512014197],{\n\n/***/ 338:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>今天在写一个通过 GitHub API 获取README 的功能的时候, 由于返回值为 Base64 编码, 我在尝试用 js 转换为 UFT-8 的时候发现中文会导致乱码. 在这里总结一下相关的知识点吧.</p>\\n</blockquote>\\n<h2>首先, 为什么要编码？</h2>\\n<p>由于一些网络通讯协议的限制, 又或者是出于信息加密的目的, 我们就需要将原信息转换为 base64 编码,然后才能进行传输.例如，发送某些含有 ASCII 码表中 0 到 31 之间的控制字符的数据。</p>\\n<p>通常的方法是通过 <code>window.btoa()</code> 方法对源数据进行编码, 然后接收方使用 <code>window.atob()</code> 方法对其进行解码, 从而得到原数据.</p>\\n<!--more-->\\n<h2>window.btoa 与 window.atob 不支持中文</h2>\\n<p>但是这种方法存在的问题是:<code>window.btoa()</code> 不支持中文, <code>window.atob()</code>转换含有中文的 base64编码的时候中文部分会变为乱码.详情如下:</p>\\n<p>我们在 bash 终端下先得到『中文』这两个字的 base64 编码</p>\\n<p>{% codeblock %}</p>\\n<p>$ echo 中文 | base64\\n5Lit5paHCg==\\n{% endcodeblock %}</p>\\n<p>然后我们在 Chrome console 里面通过 <code>window.atob</code> 进行解码, 结果如下</p>\\n<p>{% codeblock %}</p>\\n<blockquote>\\n<p>window.atob('5Lit5paHCg==')\\n&#x3C; \\\"ä¸­æ\\n\\\"\\n{% endcodeblock %}</p>\\n</blockquote>\\n<p>继续在 Chrome console 里面执行 <code>window.btoa</code> 编码, 结果报错.</p>\\n<p>{% codeblock %}</p>\\n<blockquote>\\n<p>window.btoa('中文');\\n&#x3C; Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.\\n{% endcodeblock %}</p>\\n</blockquote>\\n<p>经查资料发现, <code>btoa</code> 方法仅支持 ASCII 编码.</p>\\n<h2>借助 encodeURIComponent 和 decodeURIComponent 转义中文字符</h2>\\n<p>由于<code>btoa</code> 方法仅支持 ASCII 编码, 我们在转换中文的时候就需要先将中文转换为ASCII字符序列，再通过 btoa 进行 base64 编码, 从而实现『曲线救国』。</p>\\n<p>转换ASCII字符序列的方法我们可以借助于 <code>encodeURIComponent</code> 和 <code>decodeURIComponent</code> 这两个方法完成.</p>\\n<p>编码:\\n{% codeblock %}</p>\\n<blockquote>\\n<p>window.btoa(encodeURIComponent('中文'))\\n&#x3C; \\\"JUU0JUI4JUFEJUU2JTk2JTg3\\\"\\n{% endcodeblock %}</p>\\n</blockquote>\\n<p>解码:\\n{% codeblock %}</p>\\n<blockquote>\\n<p>decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))\\n&#x3C; \\\"中文\\\"\\n{% endcodeblock %}</p>\\n</blockquote>\\n<h2>GitHub API 获取 README 的中文乱码问题</h2>\\n<p>但是通过上面的解码方式解码 github 的 readme 数据的时候仍旧是乱码, 经过查找相关资料发现了Base64的编码与解码转的最优方案是下面这种:</p>\\n<p>{% codeblock %}\\nfunction utf8<em>to</em>b64(str) {\\nreturn window.btoa(unescape(encodeURIComponent(str)));\\n}</p>\\n<p>function b64<em>to</em>utf8(str) {\\nreturn decodeURIComponent(escape(window.atob(str)));\\n}</p>\\n<p>// Usage:\\nutf8<em>to</em>b64('✓ à la mode'); // JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ==\\nb64<em>to</em>utf8('JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ=='); // \\\"✓ à la mode\\\"</p>\\n<p>utf8<em>to</em>b64('I \\\\u2661 Unicode!'); // SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ==\\nb64<em>to</em>utf8('SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ=='); // \\\"I ♡ Unicode!\\\"\\n{% endcodeblock %}</p>\\n<p>通过上面的这种方法去解析 github 的数据的时候, 发现中文能够正常显示了. 显然 github 也是采用了这种方案.</p>\\n<h2>参考资料</h2>\\n<ul>\\n<li><a href=\\\"https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\\\">https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64<em>encoding</em>and_decoding</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa\\\">https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa</a></li>\\n</ul>\",\"frontmatter\":{\"title\":\"解决 Javascript 中 atob 方法解码中文字符乱码问题\",\"date\":\"2015-08-29\",\"category\":\"技术\",\"tags\":null}}},\"pathContext\":{\"slug\":\"/utf8-to-b64/\",\"title\":\"解决 Javascript 中 atob 方法解码中文字符乱码问题\",\"prev\":{\"fields\":{\"slug\":\"/jQuery3-0-Alpha-Versions-Released/\"},\"frontmatter\":{\"title\":\"jQuery 3.0 以及兼容版的 Alpha 版本发布\",\"category\":\"技术\",\"tags\":[\"jQuery3.0\",\"译文\"],\"cover\":null,\"date\":\"2015-11-12\"},\"excerpt\":\"从我们做出上一个重大的版本发布已经过去很长时间了，所以你理应再得到一个新版本。因此我们非常高兴的宣布  jQuery 3.0  的第一个  alpha  版本的发布。 尽管版本号已经到了 3.…\"},\"next\":false}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---utf-8-to-b-64-1b4b9c84d2d0995e0e1e.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>今天在写一个通过 GitHub API 获取README 的功能的时候, 由于返回值为 Base64 编码, 我在尝试用 js 转换为 UFT-8 的时候发现中文会导致乱码. 在这里总结一下相关的知识点吧.</p>\\n</blockquote>\\n<h2>首先, 为什么要编码？</h2>\\n<p>由于一些网络通讯协议的限制, 又或者是出于信息加密的目的, 我们就需要将原信息转换为 base64 编码,然后才能进行传输.例如，发送某些含有 ASCII 码表中 0 到 31 之间的控制字符的数据。</p>\\n<p>通常的方法是通过 <code>window.btoa()</code> 方法对源数据进行编码, 然后接收方使用 <code>window.atob()</code> 方法对其进行解码, 从而得到原数据.</p>\\n<!--more-->\\n<h2>window.btoa 与 window.atob 不支持中文</h2>\\n<p>但是这种方法存在的问题是:<code>window.btoa()</code> 不支持中文, <code>window.atob()</code>转换含有中文的 base64编码的时候中文部分会变为乱码.详情如下:</p>\\n<p>我们在 bash 终端下先得到『中文』这两个字的 base64 编码</p>\\n<p>{% codeblock %}</p>\\n<p>$ echo 中文 | base64\\n5Lit5paHCg==\\n{% endcodeblock %}</p>\\n<p>然后我们在 Chrome console 里面通过 <code>window.atob</code> 进行解码, 结果如下</p>\\n<p>{% codeblock %}</p>\\n<blockquote>\\n<p>window.atob('5Lit5paHCg==')\\n&#x3C; \\\"ä¸­æ\\n\\\"\\n{% endcodeblock %}</p>\\n</blockquote>\\n<p>继续在 Chrome console 里面执行 <code>window.btoa</code> 编码, 结果报错.</p>\\n<p>{% codeblock %}</p>\\n<blockquote>\\n<p>window.btoa('中文');\\n&#x3C; Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.\\n{% endcodeblock %}</p>\\n</blockquote>\\n<p>经查资料发现, <code>btoa</code> 方法仅支持 ASCII 编码.</p>\\n<h2>借助 encodeURIComponent 和 decodeURIComponent 转义中文字符</h2>\\n<p>由于<code>btoa</code> 方法仅支持 ASCII 编码, 我们在转换中文的时候就需要先将中文转换为ASCII字符序列，再通过 btoa 进行 base64 编码, 从而实现『曲线救国』。</p>\\n<p>转换ASCII字符序列的方法我们可以借助于 <code>encodeURIComponent</code> 和 <code>decodeURIComponent</code> 这两个方法完成.</p>\\n<p>编码:\\n{% codeblock %}</p>\\n<blockquote>\\n<p>window.btoa(encodeURIComponent('中文'))\\n&#x3C; \\\"JUU0JUI4JUFEJUU2JTk2JTg3\\\"\\n{% endcodeblock %}</p>\\n</blockquote>\\n<p>解码:\\n{% codeblock %}</p>\\n<blockquote>\\n<p>decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))\\n&#x3C; \\\"中文\\\"\\n{% endcodeblock %}</p>\\n</blockquote>\\n<h2>GitHub API 获取 README 的中文乱码问题</h2>\\n<p>但是通过上面的解码方式解码 github 的 readme 数据的时候仍旧是乱码, 经过查找相关资料发现了Base64的编码与解码转的最优方案是下面这种:</p>\\n<p>{% codeblock %}\\nfunction utf8<em>to</em>b64(str) {\\nreturn window.btoa(unescape(encodeURIComponent(str)));\\n}</p>\\n<p>function b64<em>to</em>utf8(str) {\\nreturn decodeURIComponent(escape(window.atob(str)));\\n}</p>\\n<p>// Usage:\\nutf8<em>to</em>b64('✓ à la mode'); // JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ==\\nb64<em>to</em>utf8('JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ=='); // \\\"✓ à la mode\\\"</p>\\n<p>utf8<em>to</em>b64('I \\\\u2661 Unicode!'); // SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ==\\nb64<em>to</em>utf8('SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ=='); // \\\"I ♡ Unicode!\\\"\\n{% endcodeblock %}</p>\\n<p>通过上面的这种方法去解析 github 的数据的时候, 发现中文能够正常显示了. 显然 github 也是采用了这种方案.</p>\\n<h2>参考资料</h2>\\n<ul>\\n<li><a href=\\\"https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\\\">https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64<em>encoding</em>and_decoding</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa\\\">https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa</a></li>\\n</ul>\",\"frontmatter\":{\"title\":\"解决 Javascript 中 atob 方法解码中文字符乱码问题\",\"date\":\"2015-08-29\",\"category\":\"技术\",\"tags\":null}}},\"pathContext\":{\"slug\":\"/utf8-to-b64/\",\"title\":\"解决 Javascript 中 atob 方法解码中文字符乱码问题\",\"prev\":{\"fields\":{\"slug\":\"/jQuery3-0-Alpha-Versions-Released/\"},\"frontmatter\":{\"title\":\"jQuery 3.0 以及兼容版的 Alpha 版本发布\",\"category\":\"技术\",\"tags\":[\"jQuery3.0\",\"译文\"],\"cover\":null,\"date\":\"2015-11-12\"},\"excerpt\":\"从我们做出上一个重大的版本发布已经过去很长时间了，所以你理应再得到一个新版本。因此我们非常高兴的宣布  jQuery 3.0  的第一个  alpha  版本的发布。 尽管版本号已经到了 3.…\"},\"next\":false}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/utf-8-to-b-64.json\n// module id = 338\n// module chunks = 195586512014197"],"sourceRoot":""}