{"componentChunkName":"component---src-templates-post-jsx","path":"/articles/2016/02/29/debugging-nodejs-in-chrome-devtools/","result":{"data":{"site":{"siteMetadata":{"name":"根号三","thumbnail":""}},"markdownRemark":{"frontmatter":{"title":"在 Chrome 开发者工具中调试 node.js","tags":["译文"],"cover":null,"date":"2016-02-29"},"excerpt":"原文链接 : Debugging Node.js in Chrome DevTools 原文作者 : MATT DESLAURIERS 译文出自 : 掘金翻译计划 译者 : sqrthree (根号三) 校对者: shenxn、CoderBOBO…","html":"<blockquote>\n<ul>\n<li>原文链接 : <a href=\"http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools\">Debugging Node.js in Chrome DevTools</a></li>\n<li>原文作者 : <a href=\"http://mattdesl.svbtle.com/\">MATT DESLAURIERS</a></li>\n<li>译文出自 : <a href=\"https://github.com/xitu/gold-miner\">掘金翻译计划</a></li>\n<li>译者 : <a href=\"https://github.com/sqrthree\">sqrthree (根号三)</a></li>\n<li>校对者: <a href=\"https://github.com/shenxn\">shenxn</a>、<a href=\"https://github.com/CoderBOBO\">CoderBOBO</a></li>\n</ul>\n</blockquote>\n<p>这篇文章介绍了一种在 Chrome 开发者工具里面开发、调试和分析 Node.js 应用程序的新方法。</p>\n<h2>devtool</h2>\n<p>最近我一直在开发一个命令行工具 <a href=\"https://github.com/Jam3/devtool\">devtool</a>，它可以在 Chrome 的开发者工具中运行 Node.js 程序。</p>\n<p>下面的记录显示了在一个 HTTP 服务器中设置断点的情况。</p>\n<p><img src=\"https://camo.githubusercontent.com/50a1b83c05a2995479bb27d913e12b6f25557f2c/687474703a2f2f692e696d6775722e636f6d2f56345251535a322e676966\" alt=\"movie\"></p>\n<p>该工具基于 <a href=\"https://github.com/atom/electron/\">Electron</a> 将 Node.js 和 Chromium 的功能融合在了一起。它的目的在于为调试、分析和开发 Node.js 应用程序提供一个简单的界面。</p>\n<p>你可以使用 <a href=\"http://npmjs.com/\">npm</a> 来安装它:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g devtool</code></pre></div>\n<h2>REPL</h2>\n<p>在某种程度上，我们可以用它来作为 <code class=\"language-text\">node</code> shell 命令的替代品。例如，我们可以这样打开一个 REPL (译者注: REPL 全称为\"Read-Eval-Print Loop\"，是一个简单的、交互式的编程环境)。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool</code></pre></div>\n<p>这将启动一个带有 Node.js 特性支持的 Chrome 开发者工具实例。</p>\n<p><img src=\"https://camo.githubusercontent.com/fa9fa900ca1aa0e35a5bbc41461212b98a0dfb82/687474703a2f2f692e696d6775722e636f6d2f626e496e4248412e706e67\" alt=\"console\"></p>\n<p>我们可以引用 Node 模块、本地 npm 模块和像 <code class=\"language-text\">process.cwd()</code> 这样的内置模块。也可以获取像 <code class=\"language-text\">copy()</code> 和 <code class=\"language-text\">table()</code> 这样的 Chrome 开发者工具中的函数。</p>\n<p>其他的例子就一目了然了:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># run a Node script\ndevtool app.js\n\n# pipe in content to process.stdin\ndevtool &lt; audio.mp3\n\n# pipe in JavaScript to eval it\nbrowserify index.js | devtool</code></pre></div>\n<h2>开发</h2>\n<p>我们可以在通用模块和应用程序的开发中使用 <code class=\"language-text\">devtool</code>，来代替像 <a href=\"https://www.npmjs.com/package/nodemon\">nodemon</a> 这样目前已经存在的工具。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool app.js --watch</code></pre></div>\n<p>这行命令将会在 Chrome 开发者工具中的控制台中启动我们的 <code class=\"language-text\">app.js</code>， 通过 <code class=\"language-text\">--watch</code> 参数，我们保存的文件将(自动)重新载入到控制台。</p>\n<p><img src=\"https://camo.githubusercontent.com/f7e562cdf408b8e1069be5cdc5492844a0216cb3/687474703a2f2f692e696d6775722e636f6d2f4e756f596b4a4b2e706e67\" alt=\"console\"></p>\n<p>点击 <a href=\"http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools\"><code class=\"language-text\">app.js:1</code></a> 链接，程序将会在 <code class=\"language-text\">Sources</code> 标签中把我们带到与之相关的那一行。</p>\n<p><img src=\"https://camo.githubusercontent.com/82226fac41ca329e865755aaf8191ac228a37d9c/687474703a2f2f692e696d6775722e636f6d2f6d48356a5754392e706e67\" alt=\"line\"></p>\n<p>在 <code class=\"language-text\">Sources</code> 标签中，你也可以敲击 <code class=\"language-text\">Cmd/Ctrl + P</code> 按键在所有依赖的模块中进行快速搜索。你甚至可以审查和调试内置模块，比如 Node.js 中的那些。你也可以使用左手边的面板来浏览模块。</p>\n<p><img src=\"https://camo.githubusercontent.com/8ea6bc50f269412d83761d60d24c8be3e53df953/687474703a2f2f692e696d6775722e636f6d2f6a6e33526d6e562e706e67\" alt=\"Sources\"></p>\n<h2>调试</h2>\n<p>因为我们能够访问 <code class=\"language-text\">Sources</code> 标签，所以我们可以用它来调试我们的应用程序。你可以设置一个断点，然后重新加载调试器(<code class=\"language-text\">Cmd/Ctrl + R</code>)，或者你也可以通过 <code class=\"language-text\">--break</code> 标记来设置一个初始断点。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool app.js --break</code></pre></div>\n<p><img src=\"https://camo.githubusercontent.com/a7f94f291fd37eb55e7506535f7cb33005dfb3a5/687474703a2f2f692e696d6775722e636f6d2f684a32704c57312e706e67\" alt=\"break\"></p>\n<p>下面是一些对于那些学习 Chrome 开发者工具的人来说可能不是特别常用的功能:</p>\n<ul>\n<li><a href=\"http://blittle.github.io/chrome-dev-tools/sources/conditional-breakpoints.html\">条件断点</a></li>\n<li><a href=\"http://blittle.github.io/chrome-dev-tools/sources/uncaught-exceptions.html\">有未捕获的异常时暂停</a></li>\n<li><a href=\"http://blittle.github.io/chrome-dev-tools/sources/restart-frame.html\">重启帧</a></li>\n<li><a href=\"http://albertlee.azurewebsites.net/using-watch-tools-in-chrome-dev-tools-to-improve-your-debugging/\">监听表达式</a></li>\n</ul>\n<blockquote>\n<p>提示 - 当调试器暂停时，你可以敲击 <code class=\"language-text\">Escape</code> 按键打开一个执行在当前作用域内的控制台。你可以修改一些变量然后继续执行。</p>\n</blockquote>\n<p><img src=\"https://camo.githubusercontent.com/9ee842372ed3c1374fe25e41128f1f13979f2b30/687474703a2f2f692e696d6775722e636f6d2f6e4739656c6c452e676966\" alt=\"Imgur\"></p>\n<h2>分析</h2>\n<p><code class=\"language-text\">devtool</code> 的另一个功能是分析像 <a href=\"https://github.com/substack/node-browserify\">browserify</a>, <a href=\"https://github.com/gulpjs/gulp\">gulp</a> 和 <a href=\"https://github.com/babel/babel\">babel</a> 这样的程序。</p>\n<p>这里我们使用 <a href=\"https://developer.chrome.com/devtools/docs/console-api\"><code class=\"language-text\">console.profile()</code></a> (Chrome 的一个功能)来分析一个打包工具的 CPU 使用情况。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var browserify = require(&#39;browserify&#39;);\n\n// Start DevTools profiling...\nconsole.profile(&#39;build&#39;);\n\n// Bundle some browser application\nbrowserify(&#39;client.js&#39;).bundle(function (err, src) {\n    if (err) throw err;\n\n    // Finish DevTools profiling...\n    console.profileEnd(&#39;build&#39;);\n});</code></pre></div>\n<p>现在我们在这个文件上运行 <code class=\"language-text\">devtool</code> :</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool app.js</code></pre></div>\n<p>执行之后，我们可以在 <code class=\"language-text\">Profiles</code> 标签中看到结果。</p>\n<p><img src=\"https://camo.githubusercontent.com/b677a18d13fdd723cb71e86d37122343453700b5/687474703a2f2f692e696d6775722e636f6d2f765375374c637a2e706e67\" alt=\"profile\"></p>\n<p>我们可以使用右边的链接来查看和调试执行频率较高的代码路径。</p>\n<p><img src=\"https://camo.githubusercontent.com/f5410d64be4b7074c9e0c7d6c0e3a79fbd0d1931/687474703a2f2f692e696d6775722e636f6d2f4f34445a4879762e706e67\" alt=\"debug\"></p>\n<h2>高级选项</h2>\n<h4>实验</h4>\n<p>Chrome 会不断的向他们的开发者工具中推送新功能和实验，例如 <strong>Promise Inspector</strong>。你可以通过点击右上角的三个点，然后选择 <code class=\"language-text\">Settings -&gt; Experiments</code> 来开启他们。</p>\n<p><img src=\"https://camo.githubusercontent.com/cc94d6b2c496c78fa1c1a854e82ff718b0ba461d/687474703a2f2f692e696d6775722e636f6d2f644e75494d77302e706e67\" alt=\"experiments\"></p>\n<p>一旦启用，你就可以通过敲击 <code class=\"language-text\">Escape</code> 按键来调出一个带有 <code class=\"language-text\">Promises</code> 监视器的面板。</p>\n<p><img src=\"https://camo.githubusercontent.com/6a5559e67609cada5ce00a71ccd16437110d1974/68747470733a2f2f692e696d6775722e636f6d2f784b6b544565672e706e67\"></p>\n<blockquote>\n<p>提示: 在 <em>Experiments</em> 界面，如果你敲击 <code class=\"language-text\">Shift</code> 键 6 次，你会接触到一些甚至更多的实验性（不稳定）的功能。</p>\n</blockquote>\n<h4><a href=\"http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools#codeconsolecode\"> </a><code class=\"language-text\">--console</code></h4>\n<p>你可以重定向控制台输出到终端中(<code class=\"language-text\">process.stdout</code> 和 <code class=\"language-text\">process.stderr</code>)。也允许你通过使用管道将它导入到其他进程中，例如 TAP prettifiers。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool test.js --console | tap-spec</code></pre></div>\n<h4><code class=\"language-text\">--</code> 和 <code class=\"language-text\">process.argv</code></h4>\n<p>你的脚本可以像一个普通的 Node.js 应用那样解析 <code class=\"language-text\">process.argv</code>。如果你在 <code class=\"language-text\">devtool</code> 命令中传递一个句号(<code class=\"language-text\">--</code>)，它后面的所有内容都会被当做一个新的 <code class=\"language-text\">process.argv</code> 。例如:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool script.js --console -- input.txt</code></pre></div>\n<p>现在，你的脚本看起来像这样:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var file = process.argv[2];\nconsole.log(&#39;File: %s&#39;, file);</code></pre></div>\n<p>输出:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">File: input.txt</code></pre></div>\n<h4><code class=\"language-text\">--quit</code> 和 <code class=\"language-text\">--headless</code></h4>\n<p>使用 <code class=\"language-text\">--quit</code>，当遇到了一个错误(如语法错误或者未捕获的异常)时，进程将会安静的退出，并返回结束码<code class=\"language-text\">1</code> 。</p>\n<p>使用 <code class=\"language-text\">--headless</code>，开发工具将不会被打开。</p>\n<p>这可以用于命令行脚本：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool render.js --quit --headless &gt; result.png</code></pre></div>\n<h4>)<code class=\"language-text\">--browser-field</code></h4>\n<p>一些模块为了更好的在浏览器中运行或许会提供一个入口点。当你需要这些模块时，你可以使用 <code class=\"language-text\">--browser-field</code> 来支持 <a href=\"https://github.com/defunctzombie/package-browser-field-spec\">package.json flag</a></p>\n<p>例如，我们可以使用 <a href=\"https://github.com/Jam3/xhr-request\">xhr-request</a> ，当带有 <code class=\"language-text\">&quot;browser&quot;</code> 字段被引用时，这个模块会使用 XHR。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const request = require(&#39;xhr-request&#39;);\n\nrequest(&#39;https://api.github.com/users/mattdesl/repos&#39;, {\n    json: true\n}, (err, data) =&gt; {\n    if (err) throw err;\n\n    console.log(data);\n});</code></pre></div>\n<p>在 shell 中执行:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install xhr-request --save\ndevtool app.js --browser-field</code></pre></div>\n<p>现在，我们可以在 <code class=\"language-text\">Network</code> 选项卡中审查请求:</p>\n<p><img src=\"https://camo.githubusercontent.com/a5007beaedc3e343ae9babc410f76fd02786be47/687474703a2f2f692e696d6775722e636f6d2f425763695875682e706e67\" alt=\"requests\"></p>\n<h4><code class=\"language-text\">--no-node-timers</code></h4>\n<p>默认情况下，我们提供全局的 <code class=\"language-text\">setTimeout</code> and <code class=\"language-text\">setInterval</code>，因此他们表现的像 Node.js 一样(返回一个带有 <code class=\"language-text\">unref()</code> and <code class=\"language-text\">ref()</code> 函数的对象)。</p>\n<p>但是，你可以禁用这个方法来改善对异步堆栈跟踪的支持。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">devtool app.js --no-node-timers</code></pre></div>\n<p><img src=\"https://camo.githubusercontent.com/890fc0aa560702a16b8f6ff97f02551208696a59/687474703a2f2f692e696d6775722e636f6d2f646d664f664d782e706e67\" alt=\"async\"></p>\n<h4>V8 Flags</h4>\n<p>在当前目录，你可以创建一个 <code class=\"language-text\">.devtoolrc</code> 文件来进行诸如 V8 flags 这样的高级设置。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  &quot;v8&quot;: {\n    &quot;flags&quot;: [\n      &quot;--harmony-destructuring&quot;\n    ]\n  }\n}</code></pre></div>\n<p>访问 <a href=\"https://github.com/Jam3/devtool/blob/master/docs/rc-config.md\">这里</a> 获取更多细节</p>\n<h2>陷阱</h2>\n<p>由于程序是在一个 Browser/Electron 环境中运行，而不是在一个真正的 Node.js 环境中。因此这里有<a href=\"https://github.com/Jam3/devtool#gotchas\">一些陷阱</a>你需要注意。</p>\n<h2>对比</h2>\n<p>目前已经存在了一些 Node.js 调试器，所以你或许想知道他们之间的区别在哪。</p>\n<h3>WebStorm 调试器</h3>\n<p><a href=\"https://www.jetbrains.com/webstorm/\">WebStorm</a> 编辑器里面包含了一个非常强大的 Node.js 调试器。如果你已经使用 WebStorm 作为你的代码编辑器，那对你来说很棒。</p>\n<blockquote>\n<p><img src=\"https://camo.githubusercontent.com/97481997c2175c1c6f8f490c030f0cb9b668ddc3/68747470733a2f2f692e696d6775722e636f6d2f636677473671592e706e67\"></p>\n</blockquote>\n<p>但是，它缺少一些 Chrome 开发者工具中的功能，例如:</p>\n<ul>\n<li>一个丰富的互动的控制台</li>\n<li>异常时暂停</li>\n<li>异步堆栈跟踪</li>\n<li>Promise 检查</li>\n<li>分析</li>\n</ul>\n<p>但因为你和你的 WebStorm 工作空间集成，所以你可以在调试时修改和编辑你的文件。它也是运行在一个真正的 Node/V8 环境中，而不像 <code class=\"language-text\">devtool</code> 一样。因此对于大部分的 Node.js 应用程序来说它更稳健。</p>\n<h3>iron-node</h3>\n<p><img src=\"https://camo.githubusercontent.com/974568a8cc4d0604c9798aebfc6e32a401be0ec6/68747470733a2f2f692e696d6775722e636f6d2f666b624c766f532e706e67\"></p>\n<p>一个同样基于 Electron 的调试器是<a href=\"https://github.com/s-a/iron-node\">iron-node</a>。<code class=\"language-text\">iron-node</code> 包含了一个内置的命令来重新编译原生插件，还有一个复杂的图形界面显示您的<code class=\"language-text\">package.json</code> 和 <code class=\"language-text\">README.md</code>。</p>\n<p>而 <code class=\"language-text\">devtool</code> 更侧重于把命令行、Unix 风格的管道和重定向和 Electron/Browser 的 API 当作有趣的用例。</p>\n<p><code class=\"language-text\">devtool</code> 提供各种各样的功能来表现的更像 Node.js (例如 <code class=\"language-text\">require.main</code>, <code class=\"language-text\">setTimeout</code> 和 <code class=\"language-text\">process.exit</code>)，并且覆盖了内部的 <code class=\"language-text\">require</code> 机制作为 source maps，还有改进过的错误处理、断点注入、以及 <code class=\"language-text\">&quot;browser&quot;</code> 字段的解决方案。</p>\n<h3>node-inspector</h3>\n<p><img src=\"https://camo.githubusercontent.com/874553b465d9ebaa46c6a30bada328fc31655e66/68747470733a2f2f692e696d6775722e636f6d2f54346670786a552e706e67\"></p>\n<p>你或许也喜欢 <a href=\"https://github.com/node-inspector/node-inspector\">node-inspector</a>，一个使用远程调试而不是构建在 Electron 之上的工具。</p>\n<p>这意味着你的代码将运行在一个真正的 Node 环境中，没有任何 <code class=\"language-text\">window</code> 或其他的 Browser/Electron API 来污染作用域并导致某些模块出现问题。对于大型 Node.js 应用(即本地插件)来说它有一个强有力的支持，并且在开发者工具实例中拥有更多的控制权(即可以注入断点和支持网络请求)。</p>\n<p>然而，由于它重新实现了大量的调试技巧，因此对于开发来说感觉可能比最新版的 Chrome 开发者工具要慢、笨拙和脆弱。它经常会崩溃，往往导致 Node.js 开发人员很无奈。</p>\n<p>而 <code class=\"language-text\">devtool</code> 的目的是让那些从 Chrome 开发者工具中转过来的人觉得比较亲切，而且也增加了像 Browser/Electron APIs 这样的功能。</p>\n<blockquote>\n<p>本文根据 <a href=\"http://mattdesl.svbtle.com/\">MATT DESLAURIERS</a> 的《<a href=\"http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools\">Debugging Node.js in Chrome DevTools</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href=\"http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools\">Debugging Node.js in Chrome DevTools</a></p>\n</blockquote>"}},"pageContext":{"title":"在 Chrome 开发者工具中调试 node.js","cover":null,"slug":"/debugging-nodejs-in-chrome-devtools/","excerpt":"原文链接 : Debugging Node.js in Chrome DevTools 原文作者 : MATT DESLAURIERS 译文出自 : 掘金翻译计划 译者 : sqrthree (根号三) 校对者: shenxn、CoderBOBO…","previous":{"id":"43daa127-7a7a-5a4b-9805-9b45ad679b8b","frontmatter":{"title":"前端开发书籍推荐目录","cover":null,"date":"2016-04-26"},"excerpt":"…","fields":{"slug":"/book-recommendations/"}},"next":{"id":"fe62ea04-24a1-553f-a1b2-4bab6cdf0e5c","frontmatter":{"title":"GitBook 简明教程","cover":null,"date":"2016-02-23"},"excerpt":"Modern book format and toolchain using Git and Markdown 这是 GitBook 项目主页上对 GitBook 的定义。 GitBook 是一个命令行工具。通过它，你能够使用 Git 和 Markdown…","fields":{"slug":"/gitbook/"}}}},"staticQueryHashes":["2251655042"]}