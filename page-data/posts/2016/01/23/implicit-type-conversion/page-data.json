{
    "componentChunkName": "component---node-modules-gatsby-theme-mini-src-templates-post-jsx",
    "path": "/posts/2016/01/23/implicit-type-conversion/",
    "result": {"data":{"site":{"siteMetadata":{"name":"根号三","thumbnail":""}},"markdownRemark":{"frontmatter":{"title":"聊一聊 JS 中的『隐式类型转换』","tags":["JS"],"cover":null,"date":"2016-01-23","author":"根号三"},"excerpt":"…","html":"<p>类型转换还不行？还非得隐式？这是什么高级玩意？</p>\n<p>废话不多说，我们先上一盘 🌰，额，不对，先看一个例子吧。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">3 + true</code></pre></div>\n<p>实际上在大多数编程语言中，都会认为上面这个表达式是错误的。因为布尔表达式与算术运算是不兼容的。尤其是在静态语言中，甚至不会被运行运行。即使是动态语言中，通常虽然可以让程序运行，但是会抛出一个异常。</p>\n<p>然而，然而， Javascript 不仅运行程序能够正常运行，而且还会顺利地产生结果 4。Javascript 真的是对类型错误出奇的宽容啊。看起来很像是一件好事对不对？</p>\n<p>基本上，在 Javascript 中，只有在一些极少数情况下才会因为类型错误而抛出一个异常。诸如: 调用非函数对象或者获取 null / undefined 的属性时。</p>\n<p>但是在大多数情况下，Javascript 都是不会抛出异常的。这个『小婊砸』反而按照多种多样的转换协议偷偷的强制转换为她期望的值。诺，你看，还花样转换呢，真会玩嘛。这就是所谓的『隐式类型转换』。</p>\n<p>那么，上面那个例子中，究竟是发生了什么样的转换方式呢？</p>\n<p>首先，Javascript 这个『小婊砸』在遇到算数运算符(<code class=\"language-text\">-</code> 、<code class=\"language-text\">*</code> 、<code class=\"language-text\">/</code> 和 <code class=\"language-text\">%</code>)的时候会在运算之前将参与运算的双方转换成数字。</p>\n<p>那么问题又来了，<code class=\"language-text\">true</code> 怎么就转换成数字了呢？实际上我们通过 <code class=\"language-text\">Number(true)</code> 就可以看到， <code class=\"language-text\">true</code> 转换为数字之后就是为 1，相反，<code class=\"language-text\">false</code> 转换为数字之后就对应为 0。</p>\n<p>细心的你可能发现我在上面并没有提到 <code class=\"language-text\">+</code> 运算符，那是因为它更复杂。因为它既承担着数字相加，又肩负着字符串连接操作的重任。具体的行为取决于参数的类型。</p>\n<p>但是，如果一个数字和一个字符串相加，会碰撞出什么样的火花呢？</p>\n<p>显然 Javascript 这个『小婊砸』更偏爱字符串多一点，她会将数字(<code class=\"language-text\">toString()</code>)转换为字符串，然后执行字符串连接操作。</p>\n<p>例如:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"1\" + 2;    // \"12\"\n1 + \"2\";    // \"12\"</code></pre></div>\n<p>但是，注意，Javascript 对操作顺序非常敏感，以至于会发生这样的事情:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 + 2 + \"3\";    // \"33\"</code></pre></div>\n<p>因为加法运算是自左向右的，因此它等同于下面的表达式:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(1 + 2) + \"3\";    // \"33\"</code></pre></div>\n<p>再来看这一个例子:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (1 == true) {\n    alert(\"true\");\n} else {\n    alert(\"false\");\n}</code></pre></div>\n<p>相信你一定轻松的猜到了结果对不对？</p>\n<p>但是，哼，你以为我的问题会这么简单么？那岂不是太小看你了。</p>\n<p>我们都知道，Javascript 中，数字 <code class=\"language-text\">0</code> 为假，<code class=\"language-text\">非0</code> 均为真, 那么我想问的是，在上面的条件语句中，到底是 <code class=\"language-text\">1</code> 被隐式类型转换了呢还是 <code class=\"language-text\">true</code> 被隐式类型转换了呢？</p>\n<p>实际上在条件判断运算 <code class=\"language-text\">==</code> 中的转换规则是这样的:</p>\n<ol>\n<li>如果比较的两者中有布尔值(Boolean)，会把 <code class=\"language-text\">Boolean</code> 先转换为对应的 Number，即 0 和 1，然后进行比较。</li>\n<li>如果比较的双方中有一方为 <code class=\"language-text\">Number</code>，一方为 <code class=\"language-text\">String</code>时，会把 <code class=\"language-text\">String</code> 通过 <code class=\"language-text\">Number()</code> 方法转换为数字，然后进行比较。</li>\n<li>如果比较的双方中有一方为 <code class=\"language-text\">Boolean</code>，一方为 <code class=\"language-text\">String</code>时，则会先将双方转换为数字，然后进行比较。</li>\n<li>如果比较的双方中有一方为 <code class=\"language-text\">Number</code>，一方为<code class=\"language-text\">Object</code>时，则会调用 <code class=\"language-text\">valueOf</code> 方法将<code class=\"language-text\">Object</code>转换为数字，然后进行比较。</li>\n</ol>\n<p>例如:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 == { valueOf: function() {return 1;} }    // true\n1 + { valueOf: function() {return 1;} }    // 2</code></pre></div>\n<p>需要强调的是，在 Javascript 中，只有 <code class=\"language-text\">空字符串</code>、<code class=\"language-text\">数字0</code>、<code class=\"language-text\">false</code>、<code class=\"language-text\">null</code>、<code class=\"language-text\">undefined</code> 和 <code class=\"language-text\">NaN</code> 这 6 个值为假之外，其他所有的值均为真值。</p>\n<p>说到 <code class=\"language-text\">NaN</code>，就不得不提一下 <code class=\"language-text\">isNaN()</code> 方法，<code class=\"language-text\">isNaN()</code> 方法自带隐式类型转换，该方法在测试其参数之前，会先调用 <code class=\"language-text\">Number()</code> 方法将其转换为数字。所以 <code class=\"language-text\">isNaN('1')</code> 这个语句中明明用一个字符串去测试，返回值仍然为 <code class=\"language-text\">false</code> 也就不足为怪了。</p>\n<p>在 <code class=\"language-text\">+</code> 号运算中还有一种更复杂的情况，那就是数字/字符串和对象进行运算的时候，上面已经举例说明了数字和对象运算的情况，我们再来说一下字符串和对象运算的情况。</p>\n<p>当字符串和对象进行 <code class=\"language-text\">+</code> 运算的时候，Javascript 会通过对象的 <code class=\"language-text\">toString()</code> 方法将其自身转换为字符串，然后进行连接操作。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"1\" + { toString: function() {return 1;} }    // \"11\"</code></pre></div>\n<p>之所以说它特殊，是因为当一个对象同时包含 <code class=\"language-text\">toString()</code> 和 <code class=\"language-text\">valueOf()</code> 方法的时候，运算符 <code class=\"language-text\">+</code> 应该调用哪个方法并不明显(做字符串连接还是加法应该根据其参数类型，但是由于隐式类型转换的存在，类型并不显而易见。)，Javascript 会盲目的选择 <code class=\"language-text\">valueOf()</code> 方法而不是 <code class=\"language-text\">toString()</code> 来解决这个问题。这就意味着如果你打算对一个对象做字符串连接的操作，但结果却是......</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var obj = {\n    toString: function() { return \"Object CustomObj\"; },\n    valueOf: function() { return 1; }\n};\n\nconsole.log(\"Object: \" + obj);    // \"Object: 1\"</code></pre></div>\n<p>隐式类型转换会给我们造成很多麻烦，那么该怎么避免呢？</p>\n<p>建议在所有使用条件判断的时候都使用全等运算符 <code class=\"language-text\">===</code> 来进行条件判断。全等运算符会先进行数据类型判断，并且不会发生隐式类型转换。</p>","timeToRead":4,"headings":[]}},"pageContext":{"title":"聊一聊 JS 中的『隐式类型转换』","cover":null,"slug":"/implicit-type-conversion/","permalink":"/posts/2016/01/23/implicit-type-conversion/","excerpt":"…","previous":{"id":"75d7f54c-3ae9-5a0d-a70c-42cc3e6bbf41","frontmatter":{"title":"在 Chrome 开发者工具中调试 node.js","cover":null,"date":"2016-02-29"},"excerpt":"原文链接 : Debugging Node.js in Chrome DevTools 原文作者 : MATT DESLAURIERS 译文出自 : 掘金翻译计划 译者 : sqrthree (根号三) 校对者: shenxn、CoderBOBO…","fields":{"slug":"/debugging-nodejs-in-chrome-devtools/","permalink":"/posts/2016/02/29/debugging-nodejs-in-chrome-devtools/"}},"next":{"id":"20213fb5-0bf8-5946-a2f4-21d500622cb7","frontmatter":{"title":"JavaScript 开发者年度调查报告","cover":null,"date":"2015-12-26"},"excerpt":"原文链接 : JavaScript Developer Survey Results 原文作者 : ponyfoo 译文出自 : 掘金翻译计划 译者 : sqrthree(根号三) 校对者: Zhangdroid 截止目前有超过了 500…","fields":{"slug":"/javascript-developer-survey-results/","permalink":"/posts/2015/12/26/javascript-developer-survey-results/"}},"random":[{"id":"75d7f54c-3ae9-5a0d-a70c-42cc3e6bbf41","frontmatter":{"title":"在 Chrome 开发者工具中调试 node.js","tags":["译文"],"cover":null,"date":"2016-02-29"},"excerpt":"原文链接 : Debugging Node.js in Chrome DevTools 原文作者 : MATT DESLAURIERS 译文出自 : 掘金翻译计划 译者 : sqrthree (根号三) 校对者: shenxn、CoderBOBO…","fields":{"slug":"/debugging-nodejs-in-chrome-devtools/","permalink":"/posts/2016/02/29/debugging-nodejs-in-chrome-devtools/"},"timeToRead":9},{"id":"352739bd-e460-5ae8-b6f7-3be92e0f8832","frontmatter":{"title":"一个关于 Styled Components 的五分钟介绍","tags":["译文","CSS","React"],"cover":"https://camo.githubusercontent.com/4cf7254acbf60caa799fadead24a8e35839b84af/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a4449466a69345a6d4a61345f483345706247325841772e706e67","date":"2017-02-10"},"excerpt":"原文地址：A 5-minute Intro to Styled Components 原文作者：Sacha Greif 译文出自：掘金翻译计划 译者：根号三 校对者：Tina92、lovelyCiTY CSS 是一个很神奇的语言，你可以在 1…","fields":{"slug":"/a-5-minute-intro-to-styled-components/","permalink":"/posts/2017/02/10/a-5-minute-intro-to-styled-components/"},"timeToRead":6},{"id":"b45fc168-9ee9-5aa2-8fed-faab8bb01a3d","frontmatter":{"title":"jQuery 3.0 —— 下一代的jQuery","tags":["jQuery3.0","译文"],"cover":null,"date":"2015-11-05"},"excerpt":"2014 年 10 月 29 日，jQuery 官方博客上更新了一篇博文，描述了关于下一代 jQuery 的一些信息。实际上这篇博文至今都已经一年时间了，jQuery 官方团队也早在 2015 年 7 月 1…","fields":{"slug":"/jquery3-the-next-generations/","permalink":"/posts/2015/11/05/jquery3-the-next-generations/"},"timeToRead":5}]}},
    "staticQueryHashes": ["1923471915","2251655042"]}