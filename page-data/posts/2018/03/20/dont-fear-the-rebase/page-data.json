{
    "componentChunkName": "component---node-modules-gatsby-theme-mini-src-templates-post-jsx",
    "path": "/posts/2018/03/20/dont-fear-the-rebase/",
    "result": {"data":{"site":{"siteMetadata":{"name":"根号三","thumbnail":""}},"markdownRemark":{"frontmatter":{"title":"不要害怕 Rebase","tags":["译文","Git"],"cover":"https://hackernoon.com/hn-images/1*09KWDWnv1JDeZ-LEkXpL7g.png","date":"2018-03-20","author":"根号三"},"excerpt":"原文地址：Don’t Fear The Rebase 原文作者：本文已获原作者 Jared Ready 授权，转载请注明出处。 译者：根号三 Git 的  命令是 Git 用户感到害怕和迷惑的一个常见原因，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase…","html":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\">Don’t Fear The Rebase</a></li>\n<li>原文作者：本文已获原作者 <a href=\"https://hackernoon.com/@jared.ready\">Jared Ready</a> 授权，转载请注明出处。</li>\n<li>译者：<a href=\"https://github.com/sqrthree\">根号三</a></li>\n</ul>\n</blockquote>\n<p>Git 的 <code class=\"language-text\">rebase</code> 命令是 Git 用户感到害怕和迷惑的一个常见原因，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase 是一个不可思议又充满魔力的怪兽，一上来不管三七二十一就改变历史。</p>\n<p>Rebase 有点像指针。它是这样一个令人困惑的结构：每个人都在谈论它，但是你并不清楚为什么会有人使用它，然后突然一切都“啪嗒”一下，整个想法都变得显而易见和难以置信的简单。</p>\n<p>在这篇文章中我会迫使你“啪嗒”一下，这样你就可以回到工作中并传播 <code class=\"language-text\">git rebase</code> 的神奇。</p>\n<h3 id=\"究竟什么是-rebase\" style=\"position:relative;\"><a href=\"#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF-rebase\" aria-label=\"究竟什么是 rebase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>究竟什么是 Rebase？</h3>\n<blockquote>\n<p>Git Rebase 是一个很简单的工具，用来取出一些在某个地方创建的提交，并假装它们一直是在另一个地方创建的。</p>\n</blockquote>\n<p><strong>好的，我知道了。可是这意味着什么呢？</strong></p>\n<p>让我们来看一个例子。我们在这个仓库中有两个分支：<code class=\"language-text\">master</code> 和 <code class=\"language-text\">feature/foo</code>。<code class=\"language-text\">feature/foo</code> 是基于 <code class=\"language-text\">master</code> 分离出去的分支，并且在 <code class=\"language-text\">feature/foo</code> 分支上产生了一些提交。<code class=\"language-text\">master</code> 也发生了移动，就像世界不会因为少了你的关注而停滞不前。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*RQdhYt4nNVFKlpw_q_IYow.png\" alt=\"\"></p>\n<p>这是目前的状态</p>\n<p>我们想将一些更改从 <code class=\"language-text\">master</code> 整合进 <code class=\"language-text\">feature/foo</code> 中，但是我们不想每次执行这个整合时都处理一次令人讨厌的合并提交。</p>\n<p><strong>Rebase 就是一个让你有能力整合发生在源分支上的更改而不需要执行合并（merge）从而不会产生合并提交的工具。</strong></p>\n<p><img src=\"https://hackernoon.com/hn-images/1*PZLwva5O5UoPxcrV68oYgQ.png\" alt=\"\"></p>\n<p>这是 rebase 之后的情况。（fast-forward 版本）</p>\n<p><em>D</em> 和 <em>F</em> 两个提交已经被<strong>重新放在</strong>了 <code class=\"language-text\">master</code> 的顶部，即当前指向的 <em>G</em> 提交。你可能会注意到这两个提交实际上已经被重命名为了 <em>D`</em> 和 <em>F`</em>，并且提交的 SHA-1 值也不一样。这是为什么呢？</p>\n<h4 id=\"git-中的提交不可变更\" style=\"position:relative;\"><a href=\"#git-%E4%B8%AD%E7%9A%84%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%9B%B4\" aria-label=\"git 中的提交不可变更 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Git 中的提交不可变更</h4>\n<p>一个提交具有一些与之相关的属性：一个父提交、一个时间戳、提交时仓库的快照（提交不仅仅是变更集）。这些值是 Git 在计算标识一个提交的 SHA-1 时所用到的。</p>\n<p>由于提交是不可变的，并且一个 SHA-1 应该唯一标识一个提交，因此 Git 需要创建一个新的提交来包含原始提交中相同的仓库快照，但是每个提交都有一个<strong>不同的父提交和时间戳</strong>。</p>\n<p>这导致新的提交看起来与原始提交相同，但是具有不同的 SHA-1。</p>\n<hr>\n<h3 id=\"找出提交\" style=\"position:relative;\"><a href=\"#%E6%89%BE%E5%87%BA%E6%8F%90%E4%BA%A4\" aria-label=\"找出提交 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>找出提交</h3>\n<p>当我们从 <code class=\"language-text\">feature/foo</code> 分支上运行 <code class=\"language-text\">git rebase master</code> 时，Git 怎么知道哪些提交需要移动呢？</p>\n<p>让我们先看看每个分支上的提交的文氏图（Venn diagram）。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*HbxYqw71A8ehVCTGkNOyWw.png\" alt=\"\"></p>\n<p>从上图中我们可以看到每一个分支都有 <em>A</em>、<em>B</em> 和 <em>C</em> 这几个提交。<code class=\"language-text\">master</code> 分支还拥有 <em>E</em> 和 <em>G</em> 提交但是 <code class=\"language-text\">feature/foo</code> 分支没有。<code class=\"language-text\">feature/foo</code> 拥有 <em>F</em> 和 <em>D</em> 提交但是 <code class=\"language-text\">master</code> 分支没有。</p>\n<p>Git 会做一个减法：<code class=\"language-text\">{commits on feature/foo} — {commits on master}</code>，来找出正确的提交。这个结果就是 <em>D</em> 和 <em>F</em>。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*qkRc0FH6CzwSse5CNrscfA.png\" alt=\"\"></p>\n<h4 id=\"我们能证明这一点吗\" style=\"position:relative;\"><a href=\"#%E6%88%91%E4%BB%AC%E8%83%BD%E8%AF%81%E6%98%8E%E8%BF%99%E4%B8%80%E7%82%B9%E5%90%97\" aria-label=\"我们能证明这一点吗 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>我们能证明这一点吗？</h4>\n<p>当然，一个简单方式是使用 <code class=\"language-text\">git log</code> 来看我们从这组减法中得到的确切提交。</p>\n<p><code class=\"language-text\">git log master..feature/foo</code> <strong>会</strong> 向我们展示 <code class=\"language-text\">bc1f36b</code> 和 <code class=\"language-text\">640e713</code> 提交。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*g3VrmbNmzlpuOm3Fl9Fe8w.png\" alt=\"\"></p>\n<p>如果你在 .. 后省略了一个分支，那么会默认为是当前分支。</p>\n<p>看起来不错。让我们来看看更广泛的视角以确保我不是在糊弄。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*U2qcOyvEF6CiZycntHQ_6g.png\" alt=\"\"></p>\n<p>这些 SHA-1 看起来很熟悉。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*zUQkjOT3zHCNp_6LjilQ4A.png\" alt=\"\"></p>\n<p>这里并没有 76f5fd1 和 22033eb，因为我们是从 master 分支的 7559a0b 提交开始分离的。</p>\n<hr>\n<p>如果我们现在执行一个 <code class=\"language-text\">rebase</code> 到 <code class=\"language-text\">master</code>，我们会立即看到 <code class=\"language-text\">76f5fd1</code> 和 <code class=\"language-text\">22033eb</code> 出现在我们在 <code class=\"language-text\">feature/foo</code> 分支上创建出的提交的前面。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*VLXh6HY221LdULI_i79RyQ.png\" alt=\"\"></p>\n<p>Git 正在像我们期望中的那样重新应用提交。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*cCRyFq-dsWmZWWQ-8a-RJg.png\" alt=\"\"></p>\n<p>看起来熟悉吗？</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*PZLwva5O5UoPxcrV68oYgQ.png\" alt=\"\"></p>\n<p>我们之前见过这个了。</p>\n<p>我们现在有一个很好的线性历史。你应该能够想到在此刻 fast-forward 的合并会如何发生。</p>\n<blockquote>\n<p>rebase 策略还有一个已知的额外好处，就是如果你的 CI 管道（CI pipeline）在功能分支上通过了，那么在合并后的主分支上它也会通过。如果是一个非线性的合并策略，你就不能保证这一点。</p>\n</blockquote>\n<hr>\n<h3 id=\"使用强制手段\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E5%BC%BA%E5%88%B6%E6%89%8B%E6%AE%B5\" aria-label=\"使用强制手段 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用强制手段</h3>\n<p>如果 <code class=\"language-text\">feature/foo</code> 分支已经被推送过（push），并且在 rebase 之后尝试进行另一个推送，Git 会很委婉地拒绝推送。这是为什么呢？</p>\n<p><strong>Git 会尽其所能来防止意外覆盖历史，这是一件好事。</strong></p>\n<p>我们来看一下 Git 所认为的 <code class=\"language-text\">feature/foo</code> 分支在远程仓库中是什么样的？</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*6v_6goRTKnPduN6q_x4Vpw.png\" alt=\"\"></p>\n<p>现在我们来看一下我们告诉 Git 要做的事情。</p>\n<p><img src=\"https://hackernoon.com/hn-images/1*3zndxVsC81_e7okV0aQbVg.png\" alt=\"\"></p>\n<p>从 Git 的角度来看，提交 <em>D</em> 和 <em>F</em> 即将丢弃。Git 会给你这样一行友好的信息：<code class=\"language-text\">Updates were rejected because the tip of your current branch is behind</code>。</p>\n<p>你或许会说，“但是我可以在你这个很棒的图片中清晰地看到，<code class=\"language-text\">feature/foo</code> 分支比之前更进一步了啊。” 这是一个很好的观察结果，但是 Git 只会看到远程仓库中的 <code class=\"language-text\">feature/foo</code> 包含 <code class=\"language-text\">bc1f36b</code> 和 <code class=\"language-text\">640e713</code>，但是你本地的 <code class=\"language-text\">feature/foo</code> 不包含这些提交。因此为了不丢失这些提交，Git 会委婉地拒绝一个正常的 <code class=\"language-text\">git push</code>，并要求你执行 <code class=\"language-text\">git push --force</code>。</p>\n<hr>\n<p>如果你从这篇文章中带走一件东西，那么请记住，rebase 只是简单的查找出在某个分支上创建的提交，然后使用相同的内容但是新的父提交或基础提交（<em>base</em> commit）来创建新的提交。</p>\n<hr>\n<p>如果你喜欢我的文章，请为我点赞。</p>\n<p>关注 <a href=\"https://medium.com/@hackernoon\">Hackernoon</a> 和 <a href=\"https://medium.com/@jared.ready\">Jared Ready</a> 来获取更多高质量的软件工程相关的内容吧。</p>\n<p><a href=\"https://goo.gl/w4Pbea\"><img src=\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\" alt=\"\"></a></p>\n<hr>\n<blockquote>\n<p>本文根据 <a href=\"https://hackernoon.com/@jared.ready\">Jared Ready</a> 的《<a href=\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\">Don’t Fear The Rebase</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href=\"https://hackernoon.com/dont-fear-the-rebase-bca683888dae\">https://hackernoon.com/dont-fear-the-rebase-bca683888dae</a></p>\n</blockquote>","timeToRead":6,"headings":[{"value":"究竟什么是 Rebase？","depth":3},{"value":"Git 中的提交不可变更","depth":4},{"value":"找出提交","depth":3},{"value":"我们能证明这一点吗？","depth":4},{"value":"使用强制手段","depth":3}]}},"pageContext":{"title":"不要害怕 Rebase","cover":"https://hackernoon.com/hn-images/1*09KWDWnv1JDeZ-LEkXpL7g.png","slug":"/dont-fear-the-rebase/","permalink":"/posts/2018/03/20/dont-fear-the-rebase/","excerpt":"原文地址：Don’t Fear The Rebase 原文作者：本文已获原作者 Jared Ready 授权，转载请注明出处。 译者：根号三 Git 的  命令是 Git 用户感到害怕和迷惑的一个常见原因，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase…","previous":null,"next":{"id":"790f27ee-31ea-5d7c-8673-35e50b3a4b8a","frontmatter":{"title":"GoLang 中的随机数","cover":null,"date":"2018-03-16"},"excerpt":"随机数我们都知道，就是计算机通过某种算法，“随机”的生成一个数字。很多编程语言都有内置的方法来生成随机数，那么 GoLang…","fields":{"slug":"/random-number-in-golang/","permalink":"/posts/2018/03/16/random-number-in-golang/"}},"random":[{"id":"20213fb5-0bf8-5946-a2f4-21d500622cb7","frontmatter":{"title":"JavaScript 开发者年度调查报告","tags":["译文"],"cover":null,"date":"2015-12-26"},"excerpt":"原文链接 : JavaScript Developer Survey Results 原文作者 : ponyfoo 译文出自 : 掘金翻译计划 译者 : sqrthree(根号三) 校对者: Zhangdroid 截止目前有超过了 500…","fields":{"slug":"/javascript-developer-survey-results/","permalink":"/posts/2015/12/26/javascript-developer-survey-results/"},"timeToRead":14},{"id":"a9fb74b0-b64e-52c3-bd45-e4853f6b7f02","frontmatter":{"title":"解决 Javascript 中 atob 方法解码中文字符乱码问题","tags":null,"cover":null,"date":"2015-08-29"},"excerpt":"今天在写一个通过 GitHub API 获取 README 的功能的时候, 由于返回值为 Base64 编码, 我在尝试用 js 转换为 UFT-…","fields":{"slug":"/utf8-to-b64-with-js/","permalink":"/posts/2015/08/29/utf8-to-b64-with-js/"},"timeToRead":4},{"id":"352739bd-e460-5ae8-b6f7-3be92e0f8832","frontmatter":{"title":"一个关于 Styled Components 的五分钟介绍","tags":["译文","CSS","React"],"cover":"https://camo.githubusercontent.com/4cf7254acbf60caa799fadead24a8e35839b84af/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a4449466a69345a6d4a61345f483345706247325841772e706e67","date":"2017-02-10"},"excerpt":"原文地址：A 5-minute Intro to Styled Components 原文作者：Sacha Greif 译文出自：掘金翻译计划 译者：根号三 校对者：Tina92、lovelyCiTY CSS 是一个很神奇的语言，你可以在 1…","fields":{"slug":"/a-5-minute-intro-to-styled-components/","permalink":"/posts/2017/02/10/a-5-minute-intro-to-styled-components/"},"timeToRead":6}]}},
    "staticQueryHashes": ["1923471915","2251655042"]}