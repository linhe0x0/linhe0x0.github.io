{
    "componentChunkName": "component---node-modules-gatsby-theme-mini-src-templates-post-jsx",
    "path": "/posts/2015/08/29/utf8-to-b64-with-js/",
    "result": {"data":{"site":{"siteMetadata":{"name":"根号三","thumbnail":""}},"markdownRemark":{"frontmatter":{"title":"解决 Javascript 中 atob 方法解码中文字符乱码问题","tags":null,"cover":null,"date":"2015-08-29","author":"根号三"},"excerpt":"今天在写一个通过 GitHub API 获取 README 的功能的时候, 由于返回值为 Base64 编码, 我在尝试用 js 转换为 UFT-…","html":"<blockquote>\n<p>今天在写一个通过 GitHub API 获取 README 的功能的时候, 由于返回值为 Base64 编码, 我在尝试用 js 转换为 UFT-8 的时候发现中文会导致乱码. 在这里总结一下相关的知识点吧.</p>\n</blockquote>\n<h2 id=\"首先-为什么要编码\" style=\"position:relative;\"><a href=\"#%E9%A6%96%E5%85%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BC%96%E7%A0%81\" aria-label=\"首先 为什么要编码 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>首先, 为什么要编码？</h2>\n<p>由于一些网络通讯协议的限制, 又或者是出于信息加密的目的, 我们就需要将原信息转换为 base64 编码,然后才能进行传输.例如，发送某些含有 ASCII 码表中 0 到 31 之间的控制字符的数据。</p>\n<p>通常的方法是通过 <code class=\"language-text\">window.btoa()</code> 方法对源数据进行编码, 然后接收方使用 <code class=\"language-text\">window.atob()</code> 方法对其进行解码, 从而得到原数据.</p>\n<h2 id=\"windowbtoa-与-windowatob-不支持中文\" style=\"position:relative;\"><a href=\"#windowbtoa-%E4%B8%8E-windowatob-%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87\" aria-label=\"windowbtoa 与 windowatob 不支持中文 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>window.btoa 与 window.atob 不支持中文</h2>\n<p>但是这种方法存在的问题是:<code class=\"language-text\">window.btoa()</code> 不支持中文, <code class=\"language-text\">window.atob()</code>转换含有中文的 base64 编码的时候中文部分会变为乱码.详情如下:</p>\n<p>我们在 bash 终端下先得到『中文』这两个字的 base64 编码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ echo 中文 | base64\n5Lit5paHCg==</code></pre></div>\n<p>然后我们在 Chrome console 里面通过 <code class=\"language-text\">window.atob</code> 进行解码, 结果如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> window.atob('5Lit5paHCg==')\n&lt; \"ä¸­æ\n\"</code></pre></div>\n<p>继续在 Chrome console 里面执行 <code class=\"language-text\">window.btoa</code> 编码, 结果报错.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> window.btoa('中文');\n&lt; Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.</code></pre></div>\n<p>经查资料发现, <code class=\"language-text\">btoa</code> 方法仅支持 ASCII 编码.</p>\n<h2 id=\"借助-encodeuricomponent-和-decodeuricomponent-转义中文字符\" style=\"position:relative;\"><a href=\"#%E5%80%9F%E5%8A%A9-encodeuricomponent-%E5%92%8C-decodeuricomponent-%E8%BD%AC%E4%B9%89%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6\" aria-label=\"借助 encodeuricomponent 和 decodeuricomponent 转义中文字符 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>借助 encodeURIComponent 和 decodeURIComponent 转义中文字符</h2>\n<p>由于 <code class=\"language-text\">btoa</code> 方法仅支持 ASCII 编码, 我们在转换中文的时候就需要先将中文转换为 ASCII 字符序列，再通过 btoa 进行 base64 编码, 从而实现『曲线救国』。</p>\n<p>转换 ASCII 字符序列的方法我们可以借助于 <code class=\"language-text\">encodeURIComponent</code> 和 <code class=\"language-text\">decodeURIComponent</code> 这两个方法完成.</p>\n<p>编码:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> window.btoa(encodeURIComponent('中文'))\n&lt; \"JUU0JUI4JUFEJUU2JTk2JTg3\"</code></pre></div>\n<p>解码:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))\n&lt; \"中文\"</code></pre></div>\n<h2 id=\"github-api-获取-readme-的中文乱码问题\" style=\"position:relative;\"><a href=\"#github-api-%E8%8E%B7%E5%8F%96-readme-%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98\" aria-label=\"github api 获取 readme 的中文乱码问题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GitHub API 获取 README 的中文乱码问题</h2>\n<p>但是通过上面的解码方式解码 GitHub 的 README 数据的时候仍旧是乱码, 经过查找相关资料发现了 Base64 的编码与解码转的最优方案是下面这种:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function utf8_to_b64(str) {\n  return window.btoa(unescape(encodeURIComponent(str)))\n}\n\nfunction b64_to_utf8(str) {\n  return decodeURIComponent(escape(window.atob(str)))\n}\n\n// Usage:\nutf8_to_b64('✓ à la mode'); // JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ==\nb64_to_utf8('JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ=='); // \"✓ à la mode\"\n\nutf8_to_b64('I \\u2661 Unicode!'); // SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ==\nb64_to_utf8('SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ=='); // \"I ♡ Unicode!\"</code></pre></div>\n<p>通过上面的这种方法去解析 GitHub 的数据的时候, 发现中文能够正常显示了. 显然 GitHub 也是采用了这种方案.</p>\n<h2 id=\"参考资料\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\" aria-label=\"参考资料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\">https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa\">https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa</a></li>\n</ul>","timeToRead":4,"headings":[{"value":"首先, 为什么要编码？","depth":2},{"value":"window.btoa 与 window.atob 不支持中文","depth":2},{"value":"借助 encodeURIComponent 和 decodeURIComponent 转义中文字符","depth":2},{"value":"GitHub API 获取 README 的中文乱码问题","depth":2},{"value":"参考资料","depth":2}]}},"pageContext":{"title":"解决 Javascript 中 atob 方法解码中文字符乱码问题","cover":null,"slug":"/utf8-to-b64-with-js/","permalink":"/posts/2015/08/29/utf8-to-b64-with-js/","excerpt":"今天在写一个通过 GitHub API 获取 README 的功能的时候, 由于返回值为 Base64 编码, 我在尝试用 js 转换为 UFT-…","previous":{"id":"8ee582bb-a705-5afb-b828-2c2226f36fde","frontmatter":{"title":"聊聊 JS 中的严格模式","cover":null,"date":"2015-10-09"},"excerpt":"什么是严格模式？  是 ECMAScript 5 中引入的一种将更好的错误检查引入代码中的方法，现在已经被大多浏览器实现。 顾名思义，这种模式使得 Javascript…","fields":{"slug":"/strict-mode-in-javascript/","permalink":"/posts/2015/10/09/strict-mode-in-javascript/"}},"next":null,"random":[{"id":"ced7884e-d9e3-566d-8b5c-7046709b5745","frontmatter":{"title":"jQuery 3.0 以及兼容版的 Alpha 版本发布","tags":["jQuery3.0","译文"],"cover":null,"date":"2015-11-12"},"excerpt":"从我们做出上一个重大的版本发布已经过去很长时间了，所以你理应再得到一个新版本。因此我们非常高兴的宣布  的第一个  版本的发布。 尽管版本号已经到了 3.…","fields":{"slug":"/jquery3-0-alpha-versions-released/","permalink":"/posts/2015/11/12/jquery3-0-alpha-versions-released/"},"timeToRead":13},{"id":"8ee582bb-a705-5afb-b828-2c2226f36fde","frontmatter":{"title":"聊聊 JS 中的严格模式","tags":["JS"],"cover":null,"date":"2015-10-09"},"excerpt":"什么是严格模式？  是 ECMAScript 5 中引入的一种将更好的错误检查引入代码中的方法，现在已经被大多浏览器实现。 顾名思义，这种模式使得 Javascript…","fields":{"slug":"/strict-mode-in-javascript/","permalink":"/posts/2015/10/09/strict-mode-in-javascript/"},"timeToRead":6},{"id":"20213fb5-0bf8-5946-a2f4-21d500622cb7","frontmatter":{"title":"JavaScript 开发者年度调查报告","tags":["译文"],"cover":null,"date":"2015-12-26"},"excerpt":"原文链接 : JavaScript Developer Survey Results 原文作者 : ponyfoo 译文出自 : 掘金翻译计划 译者 : sqrthree(根号三) 校对者: Zhangdroid 截止目前有超过了 500…","fields":{"slug":"/javascript-developer-survey-results/","permalink":"/posts/2015/12/26/javascript-developer-survey-results/"},"timeToRead":14}]}},
    "staticQueryHashes": ["1923471915","2251655042"]}