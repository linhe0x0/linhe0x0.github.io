---
title: "GoLang 中的随机数"
category: 技术
tags:
  - GoLang
date: "2018-03-16"
---

随机数我们都知道，就是计算机通过某种算法，“随机”的生成一个数字。很多编程语言都有内置的方法来生成随机数，那么 GoLang 中是怎样一种情况呢？

# 伪随机数

我们都知道“随机数”在现实生活中的概念，可能你随手抛一个硬币，就可以说其结果是随机的，但是在计算机中要确定一个“随机数”真的是“随机数”，那可是有标准的，不是你随随便便说是就是。

根据密码学原理，要想对一个“随机数”进行随机性检验有以下几个标准：

- 统计学伪随机性 - 在给定的随机比特流样本中，1 的数量大致等于 0 的数量，也就是说，“10”“01”“00”“11” 四者数量大致相等。说人话就是：“一眼看上去是随机的”。
- 密码学安全伪随机性 - 就是给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。
- 真随机性 - 其定义为随机样本不可重现。

根据以上几个标准，其对应的随机数也就分为以下几类：

- 伪随机数 - 满足第一个条件的随机数。
- 密码学安全的伪随机数 - 同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。
- 真随机数 -同时满足三个条件的随机数。

了解了以上几个概念，我们就知道了“伪随机数”其实就是一个“看似随机，实则并不真正随机”的数字。

# 伪随机数生成器

在实际应用中大部分情况下伪随机数就足够了。这些数列是“似乎”随机的数，实际上它们是通过一个固定的、可以重复的计算方法产生的。因为它们实际上是可以计算出来的，所以它们并不真正地随机，但是它们具有类似于随机数的统计特征。产生这样的结果的生成器我们叫做伪随机数生成器。

一般只有在密码学场景中，我们才需要使用“真随机数”。

在大部分编程语言中，提供的都是“伪随机数生成器”，例如 `JS` 中的 `Math.random()`，`GoLang` 中的 `math/rand` 包。

# GoLang 中的伪随机数

在`GoLang` 中，我们可以通过 `math/rand` 包里的方法来生成一个伪随机数：

```go
package main

import (
  "fmt"
  "math/rand"
)

func main() {
  fmt.Println(rand.Int())   // => 134020434
}
```

上面的代码中，我们通过 `rand.Int()` 方法来生成一个伪随机数。看起来好像没什么问题嘛，人家也很 OK 啦。

但是细心的你会发现，你在自己电脑上运行上面的代码竟然和我的一样。无论你怎么运行，它都一样。

我们知道 `JS` 中的 `Math.random()` 每次都会返回一个不一样的数字，但是 `GoLang` 中的伪随机数生成器默认情况下竟然会返回相同的数值，这还不反了天了？

都是伪随机数生成器，为什么差别就这么大呢？这里我们就要了解一下“随机种子”的概念啦。

# 随机种子

我们知道，伪随机数，是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。

那么自然，在计算伪随机数时假如使用的开始值不变的话，那么算法计算出的伪随机数的数序自然也是不变的咯。

这个“开始值”，就被称为随机种子。

查阅[文档](https://golang.google.cn/pkg/math/rand/#Int)，我们得知，`Int()` 函数是从 `default Source`（默认源）中产生的伪随机数。

而这个 `default Source`，我们从 [Seed](https://golang.google.cn/pkg/math/rand/#Seed) 部分可以看到，如果你没有设置随机种子，那么默认初始种子总是从 `1` 开始。

既然随机种子一样，那自然其结果也是一样的。

# 随机的伪随机数

我们已经知道了默认随机种子是从 `1` 开始，那么我们只要在每次生成随机数之前先设置一个不一样的种子，那么其结果自然也就不一样了。

我们要尽可能保证每次伪随机数生成器工作时使用的是不同的种子，通常的做法是采用当前时间作为种子。

```go
package main

import (
  "fmt"
  "math/rand"
  "time"
)

func main() {
  rand.Seed(int64(time.Now().UnixNano()))

  fmt.Println(rand.Int())
}
```

这样，由于种子不同，我们每次运行的结果也就不一样。我们就能达到获取伪随机数的目的啦。

# 真随机数

如果我们的应用对安全性要求比较高，需要使用真随机数的话，那么可以使用 `crypto/rand` 包中的方法。

```go
package main

import (
  "crypto/rand"
  "fmt"
  "math/big"
)

func main() {
  // 生成 20 个 [0, 100) 范围的真随机数。
  for i := 0; i < 20; i++ {
    result, _ := rand.Int(rand.Reader, big.NewInt(100))
    fmt.Println(result)
  }
}
```

上面的程序每次运行的结果都是不一样的，会真正随机的生成随机数。
