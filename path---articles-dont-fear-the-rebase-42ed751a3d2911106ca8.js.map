{"version":3,"sources":["webpack:///path---articles-dont-fear-the-rebase-42ed751a3d2911106ca8.js","webpack:///./.cache/json/articles-dont-fear-the-rebase.json"],"names":["webpackJsonp","391","module","exports","data","markdownRemark","html","frontmatter","title","date","category","tags","cover","site","siteMetadata","url","thumbnail","defaultAuthor","donation","status","channel","alipay","wechat","share","pathContext","slug","excerpt","prev","next","fields"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,2oTAAsxIC,aAAm+KC,MAAA,GAAAC,KAAA,KAAAC,SAAA,KAAAC,KAAA,KAAAC,MAAA,OAAiEC,MAASC,cAAgBC,IAAA,6BAAAC,UAAA,GAAAC,cAAA,MAAAC,UAAoFC,QAAA,EAAAC,SAAyBC,OAAA,mDAAAC,OAAA,mEAAuIC,OAAA,KAAgBC,aAAgBC,KAAA,yBAAAjB,MAAA,GAAAkB,QAAA,6IAAAC,MAAA,EAAAC,MAAuNC,QAAUJ,KAAA,6BAAmClB,aAAgBC,MAAA,eAAAE,SAAA,KAAAC,MAAA,UAAAC,MAAA,KAAAH,KAAA,cAA0FiB,QAAA","file":"path---articles-dont-fear-the-rebase-42ed751a3d2911106ca8.js","sourcesContent":["webpackJsonp([266053112071045],{\n\n/***/ 391:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>ä¸è¦å®³æ€• Rebase</h1>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpet99qa0jj31hc0icwg4.jpg\\\"></p>\\n<p>Gitâ€™s <code>rebase</code> command is a common source of fear and confusion for Git users, especially users who may have come from a more centralized version control system. Thatâ€™s normal. Rebase is a weird, magical looking beast that just comes in and starts changing history willy-nilly.</p>\\n<p>Git çš„ <code>rebase</code> å‘½ä»¤æ˜¯ Git ç”¨æˆ·å®³æ€•å’Œè¿·æƒ‘çš„ä¸€ä¸ªå¸¸è§æºå¤´ï¼Œç‰¹åˆ«æ˜¯é‚£äº›æ¥è‡ªå¯èƒ½æ›´é›†ä¸­çš„ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿçš„ç”¨æˆ·ã€‚è¿™å¾ˆæ­£å¸¸ã€‚Rebase æ˜¯ä¸€ä¸ª</p>\\n<p>Rebase is sort of like pointers; it is this confusing construct that everybody talks about but you have no idea why anybody would use it and then suddenly everything will <em>click</em> and the whole idea becomes glaringly obvious and incredibly simple.</p>\\n<p>I am here to force that <em>click</em> onto you so you can go into work and spread the wonder that is <code>git rebase</code>.</p>\\n<h3>What Even is a Rebase?</h3>\\n<blockquote>\\n<p>Git Rebase is simply a tool that can be used to take some commits that were made in one place and just pretend they were made in another place all along.</p>\\n</blockquote>\\n<p><strong>OK but what does that <em>mean</em>?</strong></p>\\n<p>Letâ€™s look at an example. We have two branches in this repository: <code>master</code> and <code>feature/foo</code>. <code>feature/foo</code> was branched off of <code>master</code> and some commits were made on <code>feature/foo</code>. <code>master</code> has moved on because the world doesnâ€™t just stop when you arenâ€™t looking.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*RQdhYt4nNVFKlpw_q_IYow.png?q=20\\\"><img src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"></p>\\n<p>Current state of affairs\\nWe want to integrate the changes from <code>master</code> into <code>feature/foo</code> but we donâ€™t want to deal with having a pesky merge commit every time we perform this integration.</p>\\n<p><strong>Rebase is a tool that gives you the power to integrate changes that happened on the source branch without performing a merge, and thus without having a merge commit.</strong></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/2000/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>Post-rebase. Visions of fast-forwardâ€¦</p>\\n<p>Commits <em>D</em> and <em>F</em> have been <em>replayed</em> on top of <code>master</code>, which is currently pointing at commit <em>G</em>. You will notice that these commits are actually named <em>D`</em> and <em>F`</em> and the commit SHA-1 is different. Why is this?</p>\\n<h4>Commits are Immutable in Git</h4>\\n<p>A commit has a few properties that are relevant here: a parent commit, a timestamp, and a snapshot of the repository at the time of the commit (commits are not just changesets). These values are what Git uses when it computes the SHA-1 that identifies a commit.</p>\\n<p>Since commits are immutable and a SHA-1 should uniquely identify a single commit, Git has to create new commits that contain the same repository snapshot as the original commits, but each with a <strong>different parent commit and timestamp</strong>.</p>\\n<p>This leads to new commits that look identical to the original commits, but have different SHA-1s.</p>\\n<hr>\\n<h3>Finding the Commits</h3>\\n<p>How does git know what commits to move when we run <code>git rebase master</code> from <code>feature/foo</code>?</p>\\n<p>Letâ€™s first look at a Venn diagram of the commits on each branch.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*HbxYqw71A8ehVCTGkNOyWw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*HbxYqw71A8ehVCTGkNOyWw.png\\\"></p>\\n<p>Here we see that each branch has commits <em>A</em>, <em>B</em>, and <em>C</em>. <code>master</code> has commits <em>E *and *G *that <code>feature/foo</code> does not have. <code>feature/foo</code> has commits *F</em> and <em>D</em> that <code>master</code> does not have.</p>\\n<p>Git will perform a set subtraction, <code>{commits on feature/foo} â€” {commits on master}</code>, to find the right commits. This results in commits <em>D *and *F.</em></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*qkRc0FH6CzwSse5CNrscfA.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*qkRc0FH6CzwSse5CNrscfA.png\\\"></p>\\n<h4>Can we prove this?</h4>\\n<p>Yes! An easy way is to use <code>git log</code> to see the exact commits that we get from this set subtraction.</p>\\n<p><code>git log master..feature/foo</code><em>should</em> show us commits <code>bc1f36b</code> and <code>640e713</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*g3VrmbNmzlpuOm3Fl9Fe8w.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*g3VrmbNmzlpuOm3Fl9Fe8w.png\\\"></p>\\n<p>Current branch is implied if you omit a branch after ..\\nThis looks good so far. Letâ€™s get a wider view to make sure Iâ€™m not yanking chains.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*U2qcOyvEF6CiZycntHQ_6g.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*U2qcOyvEF6CiZycntHQ_6g.png\\\"></p>\\n<p>These SHA-1s look familiar</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*zUQkjOT3zHCNp_6LjilQ4A.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*zUQkjOT3zHCNp_6LjilQ4A.png\\\"></p>\\n<p>76f5fd1 and 22033eb are missing because we diverged from master at 7559a0b</p>\\n<hr>\\n<p>If we now perform a <code>rebase</code> onto <code>master</code>, we should see commits <code>76f5fd1</code> and <code>22033eb</code> immediately before the commits that were made on <code>feature/foo</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*VLXh6HY221LdULI_i79RyQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*VLXh6HY221LdULI_i79RyQ.png\\\"></p>\\n<p>Git is replaying the commits that we expected</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*cCRyFq-dsWmZWWQ-8a-RJg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*cCRyFq-dsWmZWWQ-8a-RJg.png\\\"></p>\\n<p>Does this look familiar?</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>We saw this earlier!\\nWe now have a nice linear history. You should be able to see how a fast-forward merge would happen at this point.</p>\\n<blockquote>\\n<p>The rebase strategy has the added bonus of knowing that if your CI pipeline passes on the feature branch, it will pass on main branch post-merge. With a non-linear merge strategy, you do not have this guarantee.</p>\\n</blockquote>\\n<hr>\\n<h3>Using the Force</h3>\\n<p>If <code>feature/foo</code> were already pushed and another push is attempted after this rebase, Git will very politely decline to do the push. Why is this?</p>\\n<p><strong>Git will do everything it can to prevent an accidental overwriting of history, which is a <em>good thing</em>.</strong></p>\\n<p>Letâ€™s look at what Git thinks <code>feature/foo</code> looks like on the remote repository.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*6v_6goRTKnPduN6q_x4Vpw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*6v_6goRTKnPduN6q_x4Vpw.png\\\"></p>\\n<p>Now letâ€™s look at what weâ€™re telling Git to do.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*3zndxVsC81_e7okV0aQbVg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*3zndxVsC81_e7okV0aQbVg.png\\\"></p>\\n<p>From Gitâ€™s point of view, commits <em>D *and *F</em> are about to be lost. Git will give you a nice message along the lines of <code>Updates were rejected because the tip of your current branch is behind</code>.</p>\\n<p>You might say, â€œBut I can clearly see in the nice picture that you made, <code>feature/foo</code> is further ahead than what it was before.â€ This is a good observation, but Git just sees that <code>feature/foo</code> on the remote repository contains <code>bc1f36b</code> and <code>640e713</code> and your local version of <code>feature/foo</code> does not contain those commits. So in order to not lose these commits, Git will politely decline a normal <code>git push</code>, requiring you to perform a <code>git push --force</code>.</p>\\n<hr>\\n<p>If you take away one thing from this article, remember that a rebase simply finds commits that were made on some branch and creates new commits with the same content but with a new parent or <em>base</em> commit.</p>\\n<hr>\\n<p>If you liked what you read then ğŸ‘ to show your appreciation!</p>\\n<p>Follow <a href=\\\"https://medium.com/@hackernoon\\\">Hackernoon</a> and <a href=\\\"https://medium.com/@jared.ready\\\">Jared Ready</a> for more quality software engineering content.</p>\\n<p><a href=\\\"https://goo.gl/w4Pbea\\\">\\n<img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\\\">\\n</a></p>\",\"frontmatter\":{\"title\":\"\",\"date\":null,\"category\":null,\"tags\":null,\"cover\":null}},\"site\":{\"siteMetadata\":{\"url\":\"http://blog.sqrtthree.com/\",\"thumbnail\":\"\",\"defaultAuthor\":\"æ ¹å·ä¸‰\",\"donation\":{\"status\":true,\"channel\":{\"alipay\":\"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG\",\"wechat\":\"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG\"}},\"share\":true}}},\"pathContext\":{\"slug\":\"/dont-fear-the-rebase/\",\"title\":\"\",\"excerpt\":\"ä¸è¦å®³æ€• Rebase Gitâ€™s  rebase  command is a common source of fear and confusion for Git users, especially users who may have come from a moreâ€¦\",\"prev\":false,\"next\":{\"fields\":{\"slug\":\"/random-number-in-golang/\"},\"frontmatter\":{\"title\":\"GoLang ä¸­çš„éšæœºæ•°\",\"category\":\"æŠ€æœ¯\",\"tags\":[\"GoLang\"],\"cover\":null,\"date\":\"2018-03-16\"},\"excerpt\":\"éšæœºæ•°æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œå°±æ˜¯è®¡ç®—æœºé€šè¿‡æŸç§ç®—æ³•ï¼Œâ€œéšæœºâ€çš„ç”Ÿæˆä¸€ä¸ªæ•°å­—ã€‚å¾ˆå¤šç¼–ç¨‹è¯­è¨€éƒ½æœ‰å†…ç½®çš„æ–¹æ³•æ¥ç”Ÿæˆéšæœºæ•°ï¼Œé‚£ä¹ˆ GoLangâ€¦\"}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-dont-fear-the-rebase-42ed751a3d2911106ca8.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>ä¸è¦å®³æ€• Rebase</h1>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpet99qa0jj31hc0icwg4.jpg\\\"></p>\\n<p>Gitâ€™s <code>rebase</code> command is a common source of fear and confusion for Git users, especially users who may have come from a more centralized version control system. Thatâ€™s normal. Rebase is a weird, magical looking beast that just comes in and starts changing history willy-nilly.</p>\\n<p>Git çš„ <code>rebase</code> å‘½ä»¤æ˜¯ Git ç”¨æˆ·å®³æ€•å’Œè¿·æƒ‘çš„ä¸€ä¸ªå¸¸è§æºå¤´ï¼Œç‰¹åˆ«æ˜¯é‚£äº›æ¥è‡ªå¯èƒ½æ›´é›†ä¸­çš„ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿçš„ç”¨æˆ·ã€‚è¿™å¾ˆæ­£å¸¸ã€‚Rebase æ˜¯ä¸€ä¸ª</p>\\n<p>Rebase is sort of like pointers; it is this confusing construct that everybody talks about but you have no idea why anybody would use it and then suddenly everything will <em>click</em> and the whole idea becomes glaringly obvious and incredibly simple.</p>\\n<p>I am here to force that <em>click</em> onto you so you can go into work and spread the wonder that is <code>git rebase</code>.</p>\\n<h3>What Even is a Rebase?</h3>\\n<blockquote>\\n<p>Git Rebase is simply a tool that can be used to take some commits that were made in one place and just pretend they were made in another place all along.</p>\\n</blockquote>\\n<p><strong>OK but what does that <em>mean</em>?</strong></p>\\n<p>Letâ€™s look at an example. We have two branches in this repository: <code>master</code> and <code>feature/foo</code>. <code>feature/foo</code> was branched off of <code>master</code> and some commits were made on <code>feature/foo</code>. <code>master</code> has moved on because the world doesnâ€™t just stop when you arenâ€™t looking.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*RQdhYt4nNVFKlpw_q_IYow.png?q=20\\\"><img src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"></p>\\n<p>Current state of affairs\\nWe want to integrate the changes from <code>master</code> into <code>feature/foo</code> but we donâ€™t want to deal with having a pesky merge commit every time we perform this integration.</p>\\n<p><strong>Rebase is a tool that gives you the power to integrate changes that happened on the source branch without performing a merge, and thus without having a merge commit.</strong></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/2000/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>Post-rebase. Visions of fast-forwardâ€¦</p>\\n<p>Commits <em>D</em> and <em>F</em> have been <em>replayed</em> on top of <code>master</code>, which is currently pointing at commit <em>G</em>. You will notice that these commits are actually named <em>D`</em> and <em>F`</em> and the commit SHA-1 is different. Why is this?</p>\\n<h4>Commits are Immutable in Git</h4>\\n<p>A commit has a few properties that are relevant here: a parent commit, a timestamp, and a snapshot of the repository at the time of the commit (commits are not just changesets). These values are what Git uses when it computes the SHA-1 that identifies a commit.</p>\\n<p>Since commits are immutable and a SHA-1 should uniquely identify a single commit, Git has to create new commits that contain the same repository snapshot as the original commits, but each with a <strong>different parent commit and timestamp</strong>.</p>\\n<p>This leads to new commits that look identical to the original commits, but have different SHA-1s.</p>\\n<hr>\\n<h3>Finding the Commits</h3>\\n<p>How does git know what commits to move when we run <code>git rebase master</code> from <code>feature/foo</code>?</p>\\n<p>Letâ€™s first look at a Venn diagram of the commits on each branch.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*HbxYqw71A8ehVCTGkNOyWw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*HbxYqw71A8ehVCTGkNOyWw.png\\\"></p>\\n<p>Here we see that each branch has commits <em>A</em>, <em>B</em>, and <em>C</em>. <code>master</code> has commits <em>E *and *G *that <code>feature/foo</code> does not have. <code>feature/foo</code> has commits *F</em> and <em>D</em> that <code>master</code> does not have.</p>\\n<p>Git will perform a set subtraction, <code>{commits on feature/foo} â€” {commits on master}</code>, to find the right commits. This results in commits <em>D *and *F.</em></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*qkRc0FH6CzwSse5CNrscfA.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*qkRc0FH6CzwSse5CNrscfA.png\\\"></p>\\n<h4>Can we prove this?</h4>\\n<p>Yes! An easy way is to use <code>git log</code> to see the exact commits that we get from this set subtraction.</p>\\n<p><code>git log master..feature/foo</code><em>should</em> show us commits <code>bc1f36b</code> and <code>640e713</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*g3VrmbNmzlpuOm3Fl9Fe8w.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*g3VrmbNmzlpuOm3Fl9Fe8w.png\\\"></p>\\n<p>Current branch is implied if you omit a branch after ..\\nThis looks good so far. Letâ€™s get a wider view to make sure Iâ€™m not yanking chains.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*U2qcOyvEF6CiZycntHQ_6g.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*U2qcOyvEF6CiZycntHQ_6g.png\\\"></p>\\n<p>These SHA-1s look familiar</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*zUQkjOT3zHCNp_6LjilQ4A.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*zUQkjOT3zHCNp_6LjilQ4A.png\\\"></p>\\n<p>76f5fd1 and 22033eb are missing because we diverged from master at 7559a0b</p>\\n<hr>\\n<p>If we now perform a <code>rebase</code> onto <code>master</code>, we should see commits <code>76f5fd1</code> and <code>22033eb</code> immediately before the commits that were made on <code>feature/foo</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*VLXh6HY221LdULI_i79RyQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*VLXh6HY221LdULI_i79RyQ.png\\\"></p>\\n<p>Git is replaying the commits that we expected</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*cCRyFq-dsWmZWWQ-8a-RJg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*cCRyFq-dsWmZWWQ-8a-RJg.png\\\"></p>\\n<p>Does this look familiar?</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>We saw this earlier!\\nWe now have a nice linear history. You should be able to see how a fast-forward merge would happen at this point.</p>\\n<blockquote>\\n<p>The rebase strategy has the added bonus of knowing that if your CI pipeline passes on the feature branch, it will pass on main branch post-merge. With a non-linear merge strategy, you do not have this guarantee.</p>\\n</blockquote>\\n<hr>\\n<h3>Using the Force</h3>\\n<p>If <code>feature/foo</code> were already pushed and another push is attempted after this rebase, Git will very politely decline to do the push. Why is this?</p>\\n<p><strong>Git will do everything it can to prevent an accidental overwriting of history, which is a <em>good thing</em>.</strong></p>\\n<p>Letâ€™s look at what Git thinks <code>feature/foo</code> looks like on the remote repository.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*6v_6goRTKnPduN6q_x4Vpw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*6v_6goRTKnPduN6q_x4Vpw.png\\\"></p>\\n<p>Now letâ€™s look at what weâ€™re telling Git to do.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*3zndxVsC81_e7okV0aQbVg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*3zndxVsC81_e7okV0aQbVg.png\\\"></p>\\n<p>From Gitâ€™s point of view, commits <em>D *and *F</em> are about to be lost. Git will give you a nice message along the lines of <code>Updates were rejected because the tip of your current branch is behind</code>.</p>\\n<p>You might say, â€œBut I can clearly see in the nice picture that you made, <code>feature/foo</code> is further ahead than what it was before.â€ This is a good observation, but Git just sees that <code>feature/foo</code> on the remote repository contains <code>bc1f36b</code> and <code>640e713</code> and your local version of <code>feature/foo</code> does not contain those commits. So in order to not lose these commits, Git will politely decline a normal <code>git push</code>, requiring you to perform a <code>git push --force</code>.</p>\\n<hr>\\n<p>If you take away one thing from this article, remember that a rebase simply finds commits that were made on some branch and creates new commits with the same content but with a new parent or <em>base</em> commit.</p>\\n<hr>\\n<p>If you liked what you read then ğŸ‘ to show your appreciation!</p>\\n<p>Follow <a href=\\\"https://medium.com/@hackernoon\\\">Hackernoon</a> and <a href=\\\"https://medium.com/@jared.ready\\\">Jared Ready</a> for more quality software engineering content.</p>\\n<p><a href=\\\"https://goo.gl/w4Pbea\\\">\\n<img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\\\">\\n</a></p>\",\"frontmatter\":{\"title\":\"\",\"date\":null,\"category\":null,\"tags\":null,\"cover\":null}},\"site\":{\"siteMetadata\":{\"url\":\"http://blog.sqrtthree.com/\",\"thumbnail\":\"\",\"defaultAuthor\":\"æ ¹å·ä¸‰\",\"donation\":{\"status\":true,\"channel\":{\"alipay\":\"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG\",\"wechat\":\"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG\"}},\"share\":true}}},\"pathContext\":{\"slug\":\"/dont-fear-the-rebase/\",\"title\":\"\",\"excerpt\":\"ä¸è¦å®³æ€• Rebase Gitâ€™s  rebase  command is a common source of fear and confusion for Git users, especially users who may have come from a moreâ€¦\",\"prev\":false,\"next\":{\"fields\":{\"slug\":\"/random-number-in-golang/\"},\"frontmatter\":{\"title\":\"GoLang ä¸­çš„éšæœºæ•°\",\"category\":\"æŠ€æœ¯\",\"tags\":[\"GoLang\"],\"cover\":null,\"date\":\"2018-03-16\"},\"excerpt\":\"éšæœºæ•°æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œå°±æ˜¯è®¡ç®—æœºé€šè¿‡æŸç§ç®—æ³•ï¼Œâ€œéšæœºâ€çš„ç”Ÿæˆä¸€ä¸ªæ•°å­—ã€‚å¾ˆå¤šç¼–ç¨‹è¯­è¨€éƒ½æœ‰å†…ç½®çš„æ–¹æ³•æ¥ç”Ÿæˆéšæœºæ•°ï¼Œé‚£ä¹ˆ GoLangâ€¦\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-dont-fear-the-rebase.json\n// module id = 391\n// module chunks = 266053112071045"],"sourceRoot":""}