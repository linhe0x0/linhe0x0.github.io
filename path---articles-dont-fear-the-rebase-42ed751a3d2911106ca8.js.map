{"version":3,"sources":["webpack:///path---articles-dont-fear-the-rebase-42ed751a3d2911106ca8.js","webpack:///./.cache/json/articles-dont-fear-the-rebase.json"],"names":["webpackJsonp","391","module","exports","data","markdownRemark","html","frontmatter","title","date","category","tags","cover","site","siteMetadata","url","thumbnail","defaultAuthor","donation","status","channel","alipay","wechat","share","pathContext","slug","excerpt","prev","next","fields"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,2oTAAsxIC,aAAm+KC,MAAA,GAAAC,KAAA,KAAAC,SAAA,KAAAC,KAAA,KAAAC,MAAA,OAAiEC,MAASC,cAAgBC,IAAA,6BAAAC,UAAA,GAAAC,cAAA,MAAAC,UAAoFC,QAAA,EAAAC,SAAyBC,OAAA,mDAAAC,OAAA,mEAAuIC,OAAA,KAAgBC,aAAgBC,KAAA,yBAAAjB,MAAA,GAAAkB,QAAA,6IAAAC,MAAA,EAAAC,MAAuNC,QAAUJ,KAAA,6BAAmClB,aAAgBC,MAAA,eAAAE,SAAA,KAAAC,MAAA,UAAAC,MAAA,KAAAH,KAAA,cAA0FiB,QAAA","file":"path---articles-dont-fear-the-rebase-42ed751a3d2911106ca8.js","sourcesContent":["webpackJsonp([266053112071045],{\n\n/***/ 391:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>不要害怕 Rebase</h1>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpet99qa0jj31hc0icwg4.jpg\\\"></p>\\n<p>Git’s <code>rebase</code> command is a common source of fear and confusion for Git users, especially users who may have come from a more centralized version control system. That’s normal. Rebase is a weird, magical looking beast that just comes in and starts changing history willy-nilly.</p>\\n<p>Git 的 <code>rebase</code> 命令是 Git 用户害怕和迷惑的一个常见源头，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase 是一个</p>\\n<p>Rebase is sort of like pointers; it is this confusing construct that everybody talks about but you have no idea why anybody would use it and then suddenly everything will <em>click</em> and the whole idea becomes glaringly obvious and incredibly simple.</p>\\n<p>I am here to force that <em>click</em> onto you so you can go into work and spread the wonder that is <code>git rebase</code>.</p>\\n<h3>What Even is a Rebase?</h3>\\n<blockquote>\\n<p>Git Rebase is simply a tool that can be used to take some commits that were made in one place and just pretend they were made in another place all along.</p>\\n</blockquote>\\n<p><strong>OK but what does that <em>mean</em>?</strong></p>\\n<p>Let’s look at an example. We have two branches in this repository: <code>master</code> and <code>feature/foo</code>. <code>feature/foo</code> was branched off of <code>master</code> and some commits were made on <code>feature/foo</code>. <code>master</code> has moved on because the world doesn’t just stop when you aren’t looking.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*RQdhYt4nNVFKlpw_q_IYow.png?q=20\\\"><img src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"></p>\\n<p>Current state of affairs\\nWe want to integrate the changes from <code>master</code> into <code>feature/foo</code> but we don’t want to deal with having a pesky merge commit every time we perform this integration.</p>\\n<p><strong>Rebase is a tool that gives you the power to integrate changes that happened on the source branch without performing a merge, and thus without having a merge commit.</strong></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/2000/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>Post-rebase. Visions of fast-forward…</p>\\n<p>Commits <em>D</em> and <em>F</em> have been <em>replayed</em> on top of <code>master</code>, which is currently pointing at commit <em>G</em>. You will notice that these commits are actually named <em>D`</em> and <em>F`</em> and the commit SHA-1 is different. Why is this?</p>\\n<h4>Commits are Immutable in Git</h4>\\n<p>A commit has a few properties that are relevant here: a parent commit, a timestamp, and a snapshot of the repository at the time of the commit (commits are not just changesets). These values are what Git uses when it computes the SHA-1 that identifies a commit.</p>\\n<p>Since commits are immutable and a SHA-1 should uniquely identify a single commit, Git has to create new commits that contain the same repository snapshot as the original commits, but each with a <strong>different parent commit and timestamp</strong>.</p>\\n<p>This leads to new commits that look identical to the original commits, but have different SHA-1s.</p>\\n<hr>\\n<h3>Finding the Commits</h3>\\n<p>How does git know what commits to move when we run <code>git rebase master</code> from <code>feature/foo</code>?</p>\\n<p>Let’s first look at a Venn diagram of the commits on each branch.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*HbxYqw71A8ehVCTGkNOyWw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*HbxYqw71A8ehVCTGkNOyWw.png\\\"></p>\\n<p>Here we see that each branch has commits <em>A</em>, <em>B</em>, and <em>C</em>. <code>master</code> has commits <em>E *and *G *that <code>feature/foo</code> does not have. <code>feature/foo</code> has commits *F</em> and <em>D</em> that <code>master</code> does not have.</p>\\n<p>Git will perform a set subtraction, <code>{commits on feature/foo} — {commits on master}</code>, to find the right commits. This results in commits <em>D *and *F.</em></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*qkRc0FH6CzwSse5CNrscfA.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*qkRc0FH6CzwSse5CNrscfA.png\\\"></p>\\n<h4>Can we prove this?</h4>\\n<p>Yes! An easy way is to use <code>git log</code> to see the exact commits that we get from this set subtraction.</p>\\n<p><code>git log master..feature/foo</code><em>should</em> show us commits <code>bc1f36b</code> and <code>640e713</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*g3VrmbNmzlpuOm3Fl9Fe8w.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*g3VrmbNmzlpuOm3Fl9Fe8w.png\\\"></p>\\n<p>Current branch is implied if you omit a branch after ..\\nThis looks good so far. Let’s get a wider view to make sure I’m not yanking chains.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*U2qcOyvEF6CiZycntHQ_6g.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*U2qcOyvEF6CiZycntHQ_6g.png\\\"></p>\\n<p>These SHA-1s look familiar</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*zUQkjOT3zHCNp_6LjilQ4A.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*zUQkjOT3zHCNp_6LjilQ4A.png\\\"></p>\\n<p>76f5fd1 and 22033eb are missing because we diverged from master at 7559a0b</p>\\n<hr>\\n<p>If we now perform a <code>rebase</code> onto <code>master</code>, we should see commits <code>76f5fd1</code> and <code>22033eb</code> immediately before the commits that were made on <code>feature/foo</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*VLXh6HY221LdULI_i79RyQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*VLXh6HY221LdULI_i79RyQ.png\\\"></p>\\n<p>Git is replaying the commits that we expected</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*cCRyFq-dsWmZWWQ-8a-RJg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*cCRyFq-dsWmZWWQ-8a-RJg.png\\\"></p>\\n<p>Does this look familiar?</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>We saw this earlier!\\nWe now have a nice linear history. You should be able to see how a fast-forward merge would happen at this point.</p>\\n<blockquote>\\n<p>The rebase strategy has the added bonus of knowing that if your CI pipeline passes on the feature branch, it will pass on main branch post-merge. With a non-linear merge strategy, you do not have this guarantee.</p>\\n</blockquote>\\n<hr>\\n<h3>Using the Force</h3>\\n<p>If <code>feature/foo</code> were already pushed and another push is attempted after this rebase, Git will very politely decline to do the push. Why is this?</p>\\n<p><strong>Git will do everything it can to prevent an accidental overwriting of history, which is a <em>good thing</em>.</strong></p>\\n<p>Let’s look at what Git thinks <code>feature/foo</code> looks like on the remote repository.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*6v_6goRTKnPduN6q_x4Vpw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*6v_6goRTKnPduN6q_x4Vpw.png\\\"></p>\\n<p>Now let’s look at what we’re telling Git to do.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*3zndxVsC81_e7okV0aQbVg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*3zndxVsC81_e7okV0aQbVg.png\\\"></p>\\n<p>From Git’s point of view, commits <em>D *and *F</em> are about to be lost. Git will give you a nice message along the lines of <code>Updates were rejected because the tip of your current branch is behind</code>.</p>\\n<p>You might say, “But I can clearly see in the nice picture that you made, <code>feature/foo</code> is further ahead than what it was before.” This is a good observation, but Git just sees that <code>feature/foo</code> on the remote repository contains <code>bc1f36b</code> and <code>640e713</code> and your local version of <code>feature/foo</code> does not contain those commits. So in order to not lose these commits, Git will politely decline a normal <code>git push</code>, requiring you to perform a <code>git push --force</code>.</p>\\n<hr>\\n<p>If you take away one thing from this article, remember that a rebase simply finds commits that were made on some branch and creates new commits with the same content but with a new parent or <em>base</em> commit.</p>\\n<hr>\\n<p>If you liked what you read then 👏 to show your appreciation!</p>\\n<p>Follow <a href=\\\"https://medium.com/@hackernoon\\\">Hackernoon</a> and <a href=\\\"https://medium.com/@jared.ready\\\">Jared Ready</a> for more quality software engineering content.</p>\\n<p><a href=\\\"https://goo.gl/w4Pbea\\\">\\n<img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\\\">\\n</a></p>\",\"frontmatter\":{\"title\":\"\",\"date\":null,\"category\":null,\"tags\":null,\"cover\":null}},\"site\":{\"siteMetadata\":{\"url\":\"http://blog.sqrtthree.com/\",\"thumbnail\":\"\",\"defaultAuthor\":\"根号三\",\"donation\":{\"status\":true,\"channel\":{\"alipay\":\"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG\",\"wechat\":\"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG\"}},\"share\":true}}},\"pathContext\":{\"slug\":\"/dont-fear-the-rebase/\",\"title\":\"\",\"excerpt\":\"不要害怕 Rebase Git’s  rebase  command is a common source of fear and confusion for Git users, especially users who may have come from a more…\",\"prev\":false,\"next\":{\"fields\":{\"slug\":\"/random-number-in-golang/\"},\"frontmatter\":{\"title\":\"GoLang 中的随机数\",\"category\":\"技术\",\"tags\":[\"GoLang\"],\"cover\":null,\"date\":\"2018-03-16\"},\"excerpt\":\"随机数我们都知道，就是计算机通过某种算法，“随机”的生成一个数字。很多编程语言都有内置的方法来生成随机数，那么 GoLang…\"}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-dont-fear-the-rebase-42ed751a3d2911106ca8.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>不要害怕 Rebase</h1>\\n<p><img src=\\\"https://ws3.sinaimg.cn/large/006tKfTcly1fpet99qa0jj31hc0icwg4.jpg\\\"></p>\\n<p>Git’s <code>rebase</code> command is a common source of fear and confusion for Git users, especially users who may have come from a more centralized version control system. That’s normal. Rebase is a weird, magical looking beast that just comes in and starts changing history willy-nilly.</p>\\n<p>Git 的 <code>rebase</code> 命令是 Git 用户害怕和迷惑的一个常见源头，特别是那些来自可能更集中的版本控制系统的用户。这很正常。Rebase 是一个</p>\\n<p>Rebase is sort of like pointers; it is this confusing construct that everybody talks about but you have no idea why anybody would use it and then suddenly everything will <em>click</em> and the whole idea becomes glaringly obvious and incredibly simple.</p>\\n<p>I am here to force that <em>click</em> onto you so you can go into work and spread the wonder that is <code>git rebase</code>.</p>\\n<h3>What Even is a Rebase?</h3>\\n<blockquote>\\n<p>Git Rebase is simply a tool that can be used to take some commits that were made in one place and just pretend they were made in another place all along.</p>\\n</blockquote>\\n<p><strong>OK but what does that <em>mean</em>?</strong></p>\\n<p>Let’s look at an example. We have two branches in this repository: <code>master</code> and <code>feature/foo</code>. <code>feature/foo</code> was branched off of <code>master</code> and some commits were made on <code>feature/foo</code>. <code>master</code> has moved on because the world doesn’t just stop when you aren’t looking.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*RQdhYt4nNVFKlpw_q_IYow.png?q=20\\\"><img src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*RQdhYt4nNVFKlpw_q_IYow.png\\\"></p>\\n<p>Current state of affairs\\nWe want to integrate the changes from <code>master</code> into <code>feature/foo</code> but we don’t want to deal with having a pesky merge commit every time we perform this integration.</p>\\n<p><strong>Rebase is a tool that gives you the power to integrate changes that happened on the source branch without performing a merge, and thus without having a merge commit.</strong></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/2000/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>Post-rebase. Visions of fast-forward…</p>\\n<p>Commits <em>D</em> and <em>F</em> have been <em>replayed</em> on top of <code>master</code>, which is currently pointing at commit <em>G</em>. You will notice that these commits are actually named <em>D`</em> and <em>F`</em> and the commit SHA-1 is different. Why is this?</p>\\n<h4>Commits are Immutable in Git</h4>\\n<p>A commit has a few properties that are relevant here: a parent commit, a timestamp, and a snapshot of the repository at the time of the commit (commits are not just changesets). These values are what Git uses when it computes the SHA-1 that identifies a commit.</p>\\n<p>Since commits are immutable and a SHA-1 should uniquely identify a single commit, Git has to create new commits that contain the same repository snapshot as the original commits, but each with a <strong>different parent commit and timestamp</strong>.</p>\\n<p>This leads to new commits that look identical to the original commits, but have different SHA-1s.</p>\\n<hr>\\n<h3>Finding the Commits</h3>\\n<p>How does git know what commits to move when we run <code>git rebase master</code> from <code>feature/foo</code>?</p>\\n<p>Let’s first look at a Venn diagram of the commits on each branch.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*HbxYqw71A8ehVCTGkNOyWw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*HbxYqw71A8ehVCTGkNOyWw.png\\\"></p>\\n<p>Here we see that each branch has commits <em>A</em>, <em>B</em>, and <em>C</em>. <code>master</code> has commits <em>E *and *G *that <code>feature/foo</code> does not have. <code>feature/foo</code> has commits *F</em> and <em>D</em> that <code>master</code> does not have.</p>\\n<p>Git will perform a set subtraction, <code>{commits on feature/foo} — {commits on master}</code>, to find the right commits. This results in commits <em>D *and *F.</em></p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*qkRc0FH6CzwSse5CNrscfA.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*qkRc0FH6CzwSse5CNrscfA.png\\\"></p>\\n<h4>Can we prove this?</h4>\\n<p>Yes! An easy way is to use <code>git log</code> to see the exact commits that we get from this set subtraction.</p>\\n<p><code>git log master..feature/foo</code><em>should</em> show us commits <code>bc1f36b</code> and <code>640e713</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*g3VrmbNmzlpuOm3Fl9Fe8w.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*g3VrmbNmzlpuOm3Fl9Fe8w.png\\\"></p>\\n<p>Current branch is implied if you omit a branch after ..\\nThis looks good so far. Let’s get a wider view to make sure I’m not yanking chains.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*U2qcOyvEF6CiZycntHQ_6g.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*U2qcOyvEF6CiZycntHQ_6g.png\\\"></p>\\n<p>These SHA-1s look familiar</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*zUQkjOT3zHCNp_6LjilQ4A.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*zUQkjOT3zHCNp_6LjilQ4A.png\\\"></p>\\n<p>76f5fd1 and 22033eb are missing because we diverged from master at 7559a0b</p>\\n<hr>\\n<p>If we now perform a <code>rebase</code> onto <code>master</code>, we should see commits <code>76f5fd1</code> and <code>22033eb</code> immediately before the commits that were made on <code>feature/foo</code>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*VLXh6HY221LdULI_i79RyQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*VLXh6HY221LdULI_i79RyQ.png\\\"></p>\\n<p>Git is replaying the commits that we expected</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*cCRyFq-dsWmZWWQ-8a-RJg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*cCRyFq-dsWmZWWQ-8a-RJg.png\\\"></p>\\n<p>Does this look familiar?</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZLwva5O5UoPxcrV68oYgQ.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZLwva5O5UoPxcrV68oYgQ.png\\\"></p>\\n<p>We saw this earlier!\\nWe now have a nice linear history. You should be able to see how a fast-forward merge would happen at this point.</p>\\n<blockquote>\\n<p>The rebase strategy has the added bonus of knowing that if your CI pipeline passes on the feature branch, it will pass on main branch post-merge. With a non-linear merge strategy, you do not have this guarantee.</p>\\n</blockquote>\\n<hr>\\n<h3>Using the Force</h3>\\n<p>If <code>feature/foo</code> were already pushed and another push is attempted after this rebase, Git will very politely decline to do the push. Why is this?</p>\\n<p><strong>Git will do everything it can to prevent an accidental overwriting of history, which is a <em>good thing</em>.</strong></p>\\n<p>Let’s look at what Git thinks <code>feature/foo</code> looks like on the remote repository.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*6v_6goRTKnPduN6q_x4Vpw.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*6v_6goRTKnPduN6q_x4Vpw.png\\\"></p>\\n<p>Now let’s look at what we’re telling Git to do.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*3zndxVsC81_e7okV0aQbVg.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*3zndxVsC81_e7okV0aQbVg.png\\\"></p>\\n<p>From Git’s point of view, commits <em>D *and *F</em> are about to be lost. Git will give you a nice message along the lines of <code>Updates were rejected because the tip of your current branch is behind</code>.</p>\\n<p>You might say, “But I can clearly see in the nice picture that you made, <code>feature/foo</code> is further ahead than what it was before.” This is a good observation, but Git just sees that <code>feature/foo</code> on the remote repository contains <code>bc1f36b</code> and <code>640e713</code> and your local version of <code>feature/foo</code> does not contain those commits. So in order to not lose these commits, Git will politely decline a normal <code>git push</code>, requiring you to perform a <code>git push --force</code>.</p>\\n<hr>\\n<p>If you take away one thing from this article, remember that a rebase simply finds commits that were made on some branch and creates new commits with the same content but with a new parent or <em>base</em> commit.</p>\\n<hr>\\n<p>If you liked what you read then 👏 to show your appreciation!</p>\\n<p>Follow <a href=\\\"https://medium.com/@hackernoon\\\">Hackernoon</a> and <a href=\\\"https://medium.com/@jared.ready\\\">Jared Ready</a> for more quality software engineering content.</p>\\n<p><a href=\\\"https://goo.gl/w4Pbea\\\">\\n<img src=\\\"https://cdn-images-1.medium.com/freeze/max/60/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png?q=20\\\"><img class=\\\"progressiveMedia-noscript js-progressiveMedia-inner\\\" src=\\\"https://cdn-images-1.medium.com/max/1600/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png\\\">\\n</a></p>\",\"frontmatter\":{\"title\":\"\",\"date\":null,\"category\":null,\"tags\":null,\"cover\":null}},\"site\":{\"siteMetadata\":{\"url\":\"http://blog.sqrtthree.com/\",\"thumbnail\":\"\",\"defaultAuthor\":\"根号三\",\"donation\":{\"status\":true,\"channel\":{\"alipay\":\"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG\",\"wechat\":\"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG\"}},\"share\":true}}},\"pathContext\":{\"slug\":\"/dont-fear-the-rebase/\",\"title\":\"\",\"excerpt\":\"不要害怕 Rebase Git’s  rebase  command is a common source of fear and confusion for Git users, especially users who may have come from a more…\",\"prev\":false,\"next\":{\"fields\":{\"slug\":\"/random-number-in-golang/\"},\"frontmatter\":{\"title\":\"GoLang 中的随机数\",\"category\":\"技术\",\"tags\":[\"GoLang\"],\"cover\":null,\"date\":\"2018-03-16\"},\"excerpt\":\"随机数我们都知道，就是计算机通过某种算法，“随机”的生成一个数字。很多编程语言都有内置的方法来生成随机数，那么 GoLang…\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-dont-fear-the-rebase.json\n// module id = 391\n// module chunks = 266053112071045"],"sourceRoot":""}