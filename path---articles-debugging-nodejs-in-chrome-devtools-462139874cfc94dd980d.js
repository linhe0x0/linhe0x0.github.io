webpackJsonp([0x719be77a6fe3],{388:function(e,o){e.exports={data:{markdownRemark:{html:'<blockquote>\n<ul>\n<li>原文链接 : <a href="http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools">Debugging Node.js in Chrome DevTools</a></li>\n<li>原文作者 : <a href="http://mattdesl.svbtle.com/">MATT DESLAURIERS</a></li>\n<li>译文出自 : <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>\n<li>译者 : <a href="https://github.com/sqrthree">sqrthree (根号三)</a></li>\n<li>校对者: <a href="https://github.com/shenxn">shenxn</a>、<a href="https://github.com/CoderBOBO">CoderBOBO</a></li>\n</ul>\n</blockquote>\n<p>这篇文章介绍了一种在 Chrome 开发者工具里面开发、调试和分析 Node.js 应用程序的新方法。</p>\n<h2>devtool</h2>\n<p>最近我一直在开发一个命令行工具 <a href="https://github.com/Jam3/devtool">devtool</a>，它可以在 Chrome 的开发者工具中运行 Node.js 程序。</p>\n<p>下面的记录显示了在一个 HTTP 服务器中设置断点的情况。</p>\n<p><img src="https://camo.githubusercontent.com/50a1b83c05a2995479bb27d913e12b6f25557f2c/687474703a2f2f692e696d6775722e636f6d2f56345251535a322e676966" alt="movie"></p>\n<p>该工具基于 <a href="https://github.com/atom/electron/">Electron</a> 将 Node.js 和 Chromium 的功能融合在了一起。它的目的在于为调试、分析和开发 Node.js 应用程序提供一个简单的界面。</p>\n<p>你可以使用 <a href="http://npmjs.com/">npm</a> 来安装它:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>npm install -g devtool</code></pre>\n      </div>\n<h2>REPL</h2>\n<p>在某种程度上，我们可以用它来作为 <code>node</code> shell 命令的替代品。例如，我们可以这样打开一个 REPL (译者注: REPL 全称为"Read-Eval-Print Loop"，是一个简单的、交互式的编程环境)。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool</code></pre>\n      </div>\n<p>这将启动一个带有 Node.js 特性支持的 Chrome 开发者工具实例。</p>\n<p><img src="https://camo.githubusercontent.com/fa9fa900ca1aa0e35a5bbc41461212b98a0dfb82/687474703a2f2f692e696d6775722e636f6d2f626e496e4248412e706e67" alt="console"></p>\n<p>我们可以引用 Node 模块、本地 npm 模块和像 <code>process.cwd()</code> 这样的内置模块。也可以获取像 <code>copy()</code> 和 <code>table()</code> 这样的 Chrome 开发者工具中的函数。</p>\n<p>其他的例子就一目了然了:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># run a Node script\ndevtool app.js\n\n# pipe in content to process.stdin\ndevtool < audio.mp3\n\n# pipe in JavaScript to eval it\nbrowserify index.js | devtool</code></pre>\n      </div>\n<h2>开发</h2>\n<p>我们可以在通用模块和应用程序的开发中使用 <code>devtool</code>，来代替像 <a href="https://www.npmjs.com/package/nodemon">nodemon</a> 这样目前已经存在的工具。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool app.js --watch</code></pre>\n      </div>\n<p>这行命令将会在 Chrome 开发者工具中的控制台中启动我们的 <code>app.js</code>， 通过 <code>--watch</code> 参数，我们保存的文件将(自动)重新载入到控制台。</p>\n<p><img src="https://camo.githubusercontent.com/f7e562cdf408b8e1069be5cdc5492844a0216cb3/687474703a2f2f692e696d6775722e636f6d2f4e756f596b4a4b2e706e67" alt="console"></p>\n<p>点击 <a href="http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools"><code>app.js:1</code></a> 链接，程序将会在 <code>Sources</code> 标签中把我们带到与之相关的那一行。</p>\n<p><img src="https://camo.githubusercontent.com/82226fac41ca329e865755aaf8191ac228a37d9c/687474703a2f2f692e696d6775722e636f6d2f6d48356a5754392e706e67" alt="line"></p>\n<p>在 <code>Sources</code> 标签中，你也可以敲击 <code>Cmd/Ctrl + P</code> 按键在所有依赖的模块中进行快速搜索。你甚至可以审查和调试内置模块，比如 Node.js 中的那些。你也可以使用左手边的面板来浏览模块。</p>\n<p><img src="https://camo.githubusercontent.com/8ea6bc50f269412d83761d60d24c8be3e53df953/687474703a2f2f692e696d6775722e636f6d2f6a6e33526d6e562e706e67" alt="Sources"></p>\n<h2>调试</h2>\n<p>因为我们能够访问 <code>Sources</code> 标签，所以我们可以用它来调试我们的应用程序。你可以设置一个断点，然后重新加载调试器(<code>Cmd/Ctrl + R</code>)，或者你也可以通过 <code>--break</code> 标记来设置一个初始断点。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool app.js --break</code></pre>\n      </div>\n<p><img src="https://camo.githubusercontent.com/a7f94f291fd37eb55e7506535f7cb33005dfb3a5/687474703a2f2f692e696d6775722e636f6d2f684a32704c57312e706e67" alt="break"></p>\n<p>下面是一些对于那些学习 Chrome 开发者工具的人来说可能不是特别常用的功能:</p>\n<ul>\n<li><a href="http://blittle.github.io/chrome-dev-tools/sources/conditional-breakpoints.html">条件断点</a></li>\n<li><a href="http://blittle.github.io/chrome-dev-tools/sources/uncaught-exceptions.html">有未捕获的异常时暂停</a></li>\n<li><a href="http://blittle.github.io/chrome-dev-tools/sources/restart-frame.html">重启帧</a></li>\n<li><a href="http://albertlee.azurewebsites.net/using-watch-tools-in-chrome-dev-tools-to-improve-your-debugging/">监听表达式</a></li>\n</ul>\n<blockquote>\n<p>提示 - 当调试器暂停时，你可以敲击 <code>Escape</code> 按键打开一个执行在当前作用域内的控制台。你可以修改一些变量然后继续执行。</p>\n</blockquote>\n<p><img src="https://camo.githubusercontent.com/9ee842372ed3c1374fe25e41128f1f13979f2b30/687474703a2f2f692e696d6775722e636f6d2f6e4739656c6c452e676966" alt="Imgur"></p>\n<h2>分析</h2>\n<p><code>devtool</code> 的另一个功能是分析像 <a href="https://github.com/substack/node-browserify">browserify</a>, <a href="https://github.com/gulpjs/gulp">gulp</a> 和 <a href="https://github.com/babel/babel">babel</a> 这样的程序。</p>\n<p>这里我们使用 <a href="https://developer.chrome.com/devtools/docs/console-api"><code>console.profile()</code></a> (Chrome 的一个功能)来分析一个打包工具的 CPU 使用情况。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>var browserify = require(\'browserify\');\n\n// Start DevTools profiling...\nconsole.profile(\'build\');\n\n// Bundle some browser application\nbrowserify(\'client.js\').bundle(function (err, src) {\n    if (err) throw err;\n\n    // Finish DevTools profiling...\n    console.profileEnd(\'build\');\n});</code></pre>\n      </div>\n<p>现在我们在这个文件上运行 <code>devtool</code> :</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool app.js</code></pre>\n      </div>\n<p>执行之后，我们可以在 <code>Profiles</code> 标签中看到结果。</p>\n<p><img src="https://camo.githubusercontent.com/b677a18d13fdd723cb71e86d37122343453700b5/687474703a2f2f692e696d6775722e636f6d2f765375374c637a2e706e67" alt="profile"></p>\n<p>我们可以使用右边的链接来查看和调试执行频率较高的代码路径。</p>\n<p><img src="https://camo.githubusercontent.com/f5410d64be4b7074c9e0c7d6c0e3a79fbd0d1931/687474703a2f2f692e696d6775722e636f6d2f4f34445a4879762e706e67" alt="debug"></p>\n<h2>高级选项</h2>\n<h4>实验</h4>\n<p>Chrome 会不断的向他们的开发者工具中推送新功能和实验，例如 <strong>Promise Inspector</strong>。你可以通过点击右上角的三个点，然后选择 <code>Settings -> Experiments</code> 来开启他们。</p>\n<p><img src="https://camo.githubusercontent.com/cc94d6b2c496c78fa1c1a854e82ff718b0ba461d/687474703a2f2f692e696d6775722e636f6d2f644e75494d77302e706e67" alt="experiments"></p>\n<p>一旦启用，你就可以通过敲击 <code>Escape</code> 按键来调出一个带有 <code>Promises</code> 监视器的面板。</p>\n<p><img src="https://camo.githubusercontent.com/6a5559e67609cada5ce00a71ccd16437110d1974/68747470733a2f2f692e696d6775722e636f6d2f784b6b544565672e706e67"></p>\n<blockquote>\n<p>提示: 在 <em>Experiments</em> 界面，如果你敲击 <code>Shift</code> 键 6 次，你会接触到一些甚至更多的实验性（不稳定）的功能。</p>\n</blockquote>\n<h4><a href="http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools#codeconsolecode"> </a><code>--console</code></h4>\n<p>你可以重定向控制台输出到终端中(<code>process.stdout</code> 和 <code>process.stderr</code>)。也允许你通过使用管道将它导入到其他进程中，例如 TAP prettifiers。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool test.js --console | tap-spec</code></pre>\n      </div>\n<h4><code>--</code> 和 <code>process.argv</code></h4>\n<p>你的脚本可以像一个普通的 Node.js 应用那样解析 <code>process.argv</code>。如果你在 <code>devtool</code> 命令中传递一个句号(<code>--</code>)，它后面的所有内容都会被当做一个新的 <code>process.argv</code> 。例如:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool script.js --console -- input.txt</code></pre>\n      </div>\n<p>现在，你的脚本看起来像这样:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>var file = process.argv[2];\nconsole.log(\'File: %s\', file);</code></pre>\n      </div>\n<p>输出:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>File: input.txt</code></pre>\n      </div>\n<h4><code>--quit</code> 和 <code>--headless</code></h4>\n<p>使用 <code>--quit</code>，当遇到了一个错误(如语法错误或者未捕获的异常)时，进程将会安静的退出，并返回结束码<code>1</code> 。</p>\n<p>使用 <code>--headless</code>，开发工具将不会被打开。</p>\n<p>这可以用于命令行脚本：</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool render.js --quit --headless > result.png</code></pre>\n      </div>\n<h4>)<code>--browser-field</code></h4>\n<p>一些模块为了更好的在浏览器中运行或许会提供一个入口点。当你需要这些模块时，你可以使用 <code>--browser-field</code> 来支持 <a href="https://github.com/defunctzombie/package-browser-field-spec">package.json flag</a></p>\n<p>例如，我们可以使用 <a href="https://github.com/Jam3/xhr-request">xhr-request</a> ，当带有 <code>"browser"</code> 字段被引用时，这个模块会使用 XHR。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>const request = require(\'xhr-request\');\n\nrequest(\'https://api.github.com/users/mattdesl/repos\', {\n    json: true\n}, (err, data) => {\n    if (err) throw err;\n\n    console.log(data);\n});</code></pre>\n      </div>\n<p>在 shell 中执行:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>npm install xhr-request --save\ndevtool app.js --browser-field</code></pre>\n      </div>\n<p>现在，我们可以在 <code>Network</code> 选项卡中审查请求:</p>\n<p><img src="https://camo.githubusercontent.com/a5007beaedc3e343ae9babc410f76fd02786be47/687474703a2f2f692e696d6775722e636f6d2f425763695875682e706e67" alt="requests"></p>\n<h4><code>--no-node-timers</code></h4>\n<p>默认情况下，我们提供全局的 <code>setTimeout</code> and <code>setInterval</code>，因此他们表现的像 Node.js 一样(返回一个带有 <code>unref()</code> and <code>ref()</code> 函数的对象)。</p>\n<p>但是，你可以禁用这个方法来改善对异步堆栈跟踪的支持。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>devtool app.js --no-node-timers</code></pre>\n      </div>\n<p><img src="https://camo.githubusercontent.com/890fc0aa560702a16b8f6ff97f02551208696a59/687474703a2f2f692e696d6775722e636f6d2f646d664f664d782e706e67" alt="async"></p>\n<h4>V8 Flags</h4>\n<p>在当前目录，你可以创建一个 <code>.devtoolrc</code> 文件来进行诸如 V8 flags 这样的高级设置。</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>{\n  "v8": {\n    "flags": [\n      "--harmony-destructuring"\n    ]\n  }\n}</code></pre>\n      </div>\n<p>访问 <a href="https://github.com/Jam3/devtool/blob/master/docs/rc-config.md">这里</a> 获取更多细节</p>\n<h2>陷阱</h2>\n<p>由于程序是在一个 Browser/Electron 环境中运行，而不是在一个真正的 Node.js 环境中。因此这里有<a href="https://github.com/Jam3/devtool#gotchas">一些陷阱</a>你需要注意。</p>\n<h2>对比</h2>\n<p>目前已经存在了一些 Node.js 调试器，所以你或许想知道他们之间的区别在哪。</p>\n<h3>WebStorm 调试器</h3>\n<p><a href="https://www.jetbrains.com/webstorm/">WebStorm</a> 编辑器里面包含了一个非常强大的 Node.js 调试器。如果你已经使用 WebStorm 作为你的代码编辑器，那对你来说很棒。</p>\n<blockquote>\n<p><img src="https://camo.githubusercontent.com/97481997c2175c1c6f8f490c030f0cb9b668ddc3/68747470733a2f2f692e696d6775722e636f6d2f636677473671592e706e67"></p>\n</blockquote>\n<p>但是，它缺少一些 Chrome 开发者工具中的功能，例如:</p>\n<ul>\n<li>一个丰富的互动的控制台</li>\n<li>异常时暂停</li>\n<li>异步堆栈跟踪</li>\n<li>Promise 检查</li>\n<li>分析</li>\n</ul>\n<p>但因为你和你的 WebStorm 工作空间集成，所以你可以在调试时修改和编辑你的文件。它也是运行在一个真正的 Node/V8 环境中，而不像 <code>devtool</code> 一样。因此对于大部分的 Node.js 应用程序来说它更稳健。</p>\n<h3>iron-node</h3>\n<p><img src="https://camo.githubusercontent.com/974568a8cc4d0604c9798aebfc6e32a401be0ec6/68747470733a2f2f692e696d6775722e636f6d2f666b624c766f532e706e67"></p>\n<p>一个同样基于 Electron 的调试器是<a href="https://github.com/s-a/iron-node">iron-node</a>。<code>iron-node</code> 包含了一个内置的命令来重新编译原生插件，还有一个复杂的图形界面显示您的<code>package.json</code> 和 <code>README.md</code>。</p>\n<p>而 <code>devtool</code> 更侧重于把命令行、Unix 风格的管道和重定向和 Electron/Browser 的 API 当作有趣的用例。</p>\n<p><code>devtool</code> 提供各种各样的功能来表现的更像 Node.js (例如 <code>require.main</code>, <code>setTimeout</code> 和 <code>process.exit</code>)，并且覆盖了内部的 <code>require</code> 机制作为 source maps，还有改进过的错误处理、断点注入、以及 <code>"browser"</code> 字段的解决方案。</p>\n<h3>node-inspector</h3>\n<p><img src="https://camo.githubusercontent.com/874553b465d9ebaa46c6a30bada328fc31655e66/68747470733a2f2f692e696d6775722e636f6d2f54346670786a552e706e67"></p>\n<p>你或许也喜欢 <a href="https://github.com/node-inspector/node-inspector">node-inspector</a>，一个使用远程调试而不是构建在 Electron 之上的工具。</p>\n<p>这意味着你的代码将运行在一个真正的 Node 环境中，没有任何 <code>window</code> 或其他的 Browser/Electron API 来污染作用域并导致某些模块出现问题。对于大型 Node.js 应用(即本地插件)来说它有一个强有力的支持，并且在开发者工具实例中拥有更多的控制权(即可以注入断点和支持网络请求)。</p>\n<p>然而，由于它重新实现了大量的调试技巧，因此对于开发来说感觉可能比最新版的 Chrome 开发者工具要慢、笨拙和脆弱。它经常会崩溃，往往导致 Node.js 开发人员很无奈。</p>\n<p>而 <code>devtool</code> 的目的是让那些从 Chrome 开发者工具中转过来的人觉得比较亲切，而且也增加了像 Browser/Electron APIs 这样的功能。</p>\n<blockquote>\n<p>本文根据 <a href="http://mattdesl.svbtle.com/">MATT DESLAURIERS</a> 的《<a href="http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools">Debugging Node.js in Chrome DevTools</a>》所译，整个译文带有自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：<a href="http://mattdesl.svbtle.com/debugging-nodejs-in-chrome-devtools">Debugging Node.js in Chrome DevTools</a></p>\n</blockquote>',frontmatter:{title:"在 Chrome 开发者工具中调试 node.js",date:"2016-02-29",category:"技术",tags:["译文"],cover:null}},site:{siteMetadata:{url:"http://blog.sqrtthree.com/",thumbnail:"",defaultAuthor:"根号三",donation:{status:!0,channel:{alipay:"http://7xl8me.com1.z0.glb.clouddn.com/alipay.JPG",wechat:"http://7xl8me.com1.z0.glb.clouddn.com/wechat_receive_money.JPG"}},share:!0}}},pathContext:{slug:"/debugging-nodejs-in-chrome-devtools/",title:"在 Chrome 开发者工具中调试 node.js",excerpt:"原文链接 :  Debugging Node.js in Chrome DevTools 原文作者 :  MATT DESLAURIERS 译文出自 :  掘金翻译计划 译者 :  sqrthree (根号三) 校对者:  shenxn 、 CoderBOBO…",prev:{fields:{slug:"/book-recommendations/"},frontmatter:{title:"前端开发书籍推荐目录",category:"技术",tags:["资源"],cover:null,date:"2016-04-26"},excerpt:"…"},next:{fields:{slug:"/gitbook/"},frontmatter:{title:"GitBook 简明教程",category:"技术",tags:["GitBook","工具"],cover:null,date:"2016-02-23"},excerpt:"Modern book format and toolchain using Git and Markdown 这是 GitBook 项目主页上对 GitBook 的定义。 GitBook 是一个命令行工具。通过它，你能够使用 Git 和 Markdown…"}}}}});
//# sourceMappingURL=path---articles-debugging-nodejs-in-chrome-devtools-462139874cfc94dd980d.js.map